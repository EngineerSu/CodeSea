## 二分查找

### 两个有序数组的中位数

#### 子问题:两个有序数组第k小的数

要求主问题的时间复杂度是O(log(M+N)).假设在子问题解决的基础上,调用子问题的函数就可以解决主问题.

```
m = 数组1长度;
n = 数组2长度;
找第(m+n+1)/2 和 (m+n+2)/2 小的数,它们的平均数就是中位数.无论两个有序数组总长度是奇数还是偶数
```

```
子问题解决思路:
1.异常情况:如果K>两个数组长度之和,返回null
2.一般情况:利用二分K的思想,找第K小的数,先分别去找两个数组第K/2小的数(假设分别为num1[p1],num2[p2]),如果num1[p1]<num2[p2],可以知道第k小的数一定不会出现在num的p1及它之前的位置,所以这些数据可以排除掉.等价于p1往右移动K/2个位置. 然后问题又变成了在两个有序数组中,寻找第K-K/2小的数.(寻找起点为p1和p2)
这里假设的是两个数组从它们的p位置开始,都能找到第K/2小的数,但是有可能有一个数组从p位置开始长度就没有K/2,此时直接让另一个较长数组的p位置往右移动K/2个位置,因为这些位置肯定不可能找到第K小的数.
3.base-case:注意,有两种base-case!!!
	1.递归到K==1时,直接return Math.min(num1[p1], num2[p2])
	2.可能某个数组刚好比较完一次后,往右移动K/2恰好出界,此时表明这个数组所有的数都被排除了
		因此,可以直接return另外一个数组的第K-K/2小的数

核心思路:利用递归,每次排除K/2个数,相当于对K做二分.排除策略有两种,注意理解.base-case也有两种,不要遗漏!
```

```java
public static double findMedianSortedArrays(int[] nums1, int[] nums2) {

    int m = nums1.length;
    int n = nums2.length;
    int a = findKOrderedNum(nums1, nums2, 0, 0, (m+n+1)/2);
    int b = findKOrderedNum(nums1, nums2, 0, 0, (m+n+2)/2);
    return (a+b)/2.0;

}

public static Integer findKOrderedNum(int[] num1, int[] num2, int p1, int p2, int K){

    if(num1 == null || num1.length == 0){ // 异常处理
        return findKOrderedNum(num2, p2, K);
    } else if(num2 == null || num2.length == 0) {
        return findKOrderedNum(num1, p1, K);
    }

    if(K == 1){ // base-case1
        return Math.min(num1[p1], num2[p2]);
    }

    if(num1.length - p1 < K/2){ // 排除策略1
        return findKOrderedNum(num1, num2, p1, p2+K/2, K-K/2);
    } else if(num2.length - p2 < K/2) {
        return findKOrderedNum(num1, num2, p1+K/2, p2, K-K/2);
    }

    if(num1[p1+K/2-1] > num2[p2+K/2-1]){ // 排除策略2
        p2 = p2+K/2;
        if(p2 == num2.length){ // base-case2
            return num1[p1+K-K/2-1];
        }
    } else {
        p1 = p1+K/2;
        if(p1 == num1.length){
            return num2[p2+K-K/2-1];
        }
    }

    return findKOrderedNum(num1, num2, p1, p2, K-K/2);

}

public static Integer findKOrderedNum(int[] num, int p, int K){
    if(num == null)
        return null;
    return p+K-1 >= num.length ? null : num[p+K-1];
}
```

