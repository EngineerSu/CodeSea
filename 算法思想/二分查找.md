## 二分查找

### 目录

* [两个有序数组的中位数](#两个有序数组的中位数)
* [Search in Rotated Sorted Array](#Search in Rotated Sorted Array)
* [数字在排序数组中出现的次数](#数字在排序数组中出现的次数)
* [旋转有序数组的最小值求解](#旋转有序数组的最小值求解)



----

### 二分查找的边界问题

二分查找的一般步骤是根据`mid = (left + right) / 2`, 然后根据arr[mid]大小比较, 决定下一个查找区间是在mid左边, 还是mid右边, 即一般是一个递归过程, 所以需要注意下一个区间边界值的选取 以及 递归终止条件的判断.

如果已知在判断条件下, mid处一定不会是击中值, 那么下一个区间边界就是[left, mid-1] 或 [mid+1, right]

三个值时, mid取中间, 两个值时, mid取左边. 所以如果有[mid, right]的判断区间, 递归终止条件需要有left + 1 == right. 即两个值时就需要终止, 不然可能会存在一直两值无限递归





### 两个有序数组的中位数

[回到目录](#目录)

**子问题:两个有序数组第k小的数**

要求主问题的时间复杂度是O(log(M+N)).假设在子问题解决的基础上,调用子问题的函数就可以解决主问题.

```
m = 数组1长度;
n = 数组2长度;
找第(m+n+1)/2 和 (m+n+2)/2 小的数,它们的平均数就是中位数.无论两个有序数组总长度是奇数还是偶数
```

```
子问题解决思路:
1.异常情况:如果K>两个数组长度之和,返回null
2.一般情况:利用二分K的思想,找第K小的数,先分别去找两个数组第K/2小的数(假设分别为num1[p1],num2[p2]),如果num1[p1]<num2[p2],可以知道第k小的数一定不会出现在num的p1及它之前的位置,所以这些数据可以排除掉.等价于p1往右移动K/2个位置. 然后问题又变成了在两个有序数组中,寻找第K-K/2小的数.(寻找起点为p1和p2)
这里假设的是两个数组从它们的p位置开始,都能找到第K/2小的数,但是有可能有一个数组从p位置开始长度就没有K/2,此时直接让另一个较长数组的p位置往右移动K/2个位置,因为这些位置肯定不可能找到第K小的数.
3.base-case:注意,有两种base-case!!!
	1.递归到K==1时,直接return Math.min(num1[p1], num2[p2])
	2.可能某个数组刚好比较完一次后,往右移动K/2恰好出界,此时表明这个数组所有的数都被排除了
		因此,可以直接return另外一个数组的第K-K/2小的数

核心思路:利用递归,每次排除K/2个数,相当于对K做二分.排除策略有两种,注意理解.base-case也有两种,不要遗漏!
```

```java
public static double findMedianSortedArrays(int[] nums1, int[] nums2) {

    int m = nums1.length;
    int n = nums2.length;
    int a = findKOrderedNum(nums1, nums2, 0, 0, (m+n+1)/2);
    int b = findKOrderedNum(nums1, nums2, 0, 0, (m+n+2)/2);
    return (a+b)/2.0;

}

public static Integer findKOrderedNum(int[] num1, int[] num2, int p1, int p2, int K){

    if(num1 == null || num1.length == 0){ // 异常处理
        return findKOrderedNum(num2, p2, K);
    } else if(num2 == null || num2.length == 0) {
        return findKOrderedNum(num1, p1, K);
    }

    if(K == 1){ // base-case1
        return Math.min(num1[p1], num2[p2]);
    }

    if(num1.length - p1 < K/2){ // 排除策略1
        return findKOrderedNum(num1, num2, p1, p2+K/2, K-K/2);
    } else if(num2.length - p2 < K/2) {
        return findKOrderedNum(num1, num2, p1+K/2, p2, K-K/2);
    }

    if(num1[p1+K/2-1] > num2[p2+K/2-1]){ // 排除策略2
        p2 = p2+K/2;
        if(p2 == num2.length){ // base-case2
            return num1[p1+K-K/2-1];
        }
    } else {
        p1 = p1+K/2;
        if(p1 == num1.length){
            return num2[p2+K-K/2-1];
        }
    }

    return findKOrderedNum(num1, num2, p1, p2, K-K/2);

}

public static Integer findKOrderedNum(int[] num, int p, int K){
    if(num == null)
        return null;
    return p+K-1 >= num.length ? null : num[p+K-1];
}
```



### Search in Rotated Sorted Array

[二分查找目录](#目录)

Q：给定一个数组arr，它是由一个递增的数组旋转得到，比如[4,5,6,7,0,1,2]，假设这个数组没有重复的数字，给定一个num，返回它在这个数组中的index，如果没有返回-1，要求时间复杂度O(logN)

A：在[left， right]区间中寻找mid，如果arr[mid]>arr[right]，表明[left, mid-1]是有序递增部分，反之[mid+1, right]是有序递增部分，在有序递增部分确定有没有num存在是很简单的，如果不存在就去另一部分寻找。

````java
class Solution {
    public int search(int[] nums, int target) {
        if(nums==null || nums.length==0){
            return -1;
        }
        
        return process(nums, target, 0, nums.length-1);
    }
    
    private static int process(int[] nums, int target, int left, int right){
        if(left == right){
            return nums[left]==target ? left : -1;
        } else if(left > right){
            return -1;
        }
        
        int mid = (left + right) >> 1;
        if(nums[mid] == target){
            return mid;
        }
        if(nums[mid] <= nums[right]){ // 右边是升序的
            if(target>nums[mid] && target<=nums[rig
                                                、】ht]){ // 有序区间确定是否有很简单
                return process(nums, target, mid+1, right);
            } else {
                return process(nums, target, left, mid-1);
            }
        } else { // 左边是升序的
            if(target<nums[mid] && target>=nums[left]){ // 有序区间确定是否有很简单
                return process(nums, target, left, mid-1);                
            } else {
                return process(nums, target, mid+1, right);
            }            
        }
    }
}
````



### 数字在排序数组中出现的次数

[二分查找目录](#目录)

Q: 给一个排序数组,问其中某个数在数组中出现的次数

A: 分别用二分法寻找这个数出现的左边界和有边界, 注意这个数可能不存在. 

```java
public class KTimesInOrderedArray {
    // Q: 对于有序数组arr,求数num在arr中出现的次数
    // A: 使用二分法分别寻找num出现的左边界和右边界,时间复杂度O(logN)

    public int findKTimesInOrderedArray(int[] arr, int num) {
        int left = findLeftBorder(arr, num, 0, arr.length - 1);
        // 没有左边界表明数据不存在提前返回
        if (left == -1) {
            return 0;
        }
        int right = findRightBorder(arr, num, 0, arr.length - 1);
        // 不存在会提前返回,所有到这里说明有边界一定存在
        return right - left + 1;
    }

    private int findRightBorder(int[] arr, int num, int left, int right) {
        if (left + 1 == right) {
            if (arr[right] == num) {
                return right;
            } else if (arr[left] == num) {
                return left;
            } else {
                return -1;
            }
        } else if (left == right) {
            return arr[left] == num ? left : -1;
        }
        int mid = (left + right) / 2;
        if (arr[mid] == num) {
            return findRightBorder(arr, num, mid, right);
        } else if (arr[mid] > num) {
            return findRightBorder(arr, num, left, mid - 1);
        } else {
            return findRightBorder(arr, num, mid + 1, right);
        }
    }

    private int findLeftBorder(int[] arr, int num, int left, int right) {
        if (left > right) {
            return -1;
        } else if (left == right) {
            return arr[left] == num ? left : -1;
        }
        int mid = (left + right) / 2;
        if (arr[mid] == num) {
            return findLeftBorder(arr, num, left, mid);
        } else if (arr[mid] > num) {
            return findLeftBorder(arr, num, left, mid - 1);
        } else {
            return findLeftBorder(arr, num, mid + 1, right);
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[]{1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 9, 10, 15, 999, 1000, 1000};
        System.out.println(new KTimesInOrderedArray().findKTimesInOrderedArray(arr, 1000));
    }
}
```



### 旋转有序数组的最小值求解

[二分查找目录](#目录)

Q: 将有序数组前面0~i位移动到原数组的末尾,称为数组的旋转.给一个旋转数组,求其最小值

A: 若`arr[left] < arr[right]`, 表明[left, right]之间依旧是非降序排序, 所以最小值就是arr[left]. 若`arr[left] >= arr[right]`, 求left和right处的中间位置mid, 先来看一种特殊情况: `arr[left] == arr[mid] && arr[mid] == arr[right]`时, 是无法判断下一步应该在mid左边还是右边寻找最小值, 这种情况只能遍历[left, right]求最小值. 如果不是这种情况, 若`arr[mid] >= arr[left]`, 那么表明在[left, mid]之间是非降序排列的, 最小值可以在[mid+1, right]中寻找, 反之最小值在[left, mid]之中寻找.

```java
public class FindMinValueInRotatingOrderedArray {
    // Q:对于一个非降序的有序数组,将其0~i位置旋转到有序数组的末尾,求旋转后数组的最小值
    // A:遍历的时间复杂度是O(N),这里可以用二分法达到O(logN)的时间复杂度

    public Integer findMinValueInRotatingOrderedArray(int[] arr) {
        if (null == arr || 0 == arr.length) {
            return null;
        }
        return findMinValueInRotatingOrderedArray(arr, 0, arr.length - 1);
    }

    /*
     * arr[left] < arr[right]:是有序部分,最小值即arr[left]
     * arr[left] >= arr[right] && arr[left] == arr[mid] == arr[right]:无法用二分法判断最小值在mid左边还是右边,只能遍历
     * arr[left] >= arr[right] && arr[mid] <= arr[right]:最小值在mid左边
     * arr[left] >= arr[right] && arr[mid] >= arr[left]:最小值在mid右边
     * */
    private Integer findMinValueInRotatingOrderedArray(int[] arr, int left, int right) {
        // 如果只有一个元素,或者左边<右边表示整个递增即击中最小值
        if (left == right || arr[left] < arr[right]) {
            return arr[left];
        }
        int mid = (left + right) / 2;
        // 左中右都相等时无法二分判断
        if (arr[left] == arr[mid] && arr[mid] == arr[right]) {
            int min = arr[left];
            while (left++ < right) {
                if (min > arr[left]) {
                    min = arr[left];
                }
            }
            return min;
        }
        if (arr[mid] >= arr[left]) {
            // 不小于左边时,二分判断在右边
            // 因为两个元素时,mid其实就是left,所以判断在右边的时候如果用[mid, right]可能会无限递归
            return findMinValueInRotatingOrderedArray(arr, mid + 1, right);
        } else {
            // 否则二分判断在左边
            // 因为即使两个元素时,mid也不会等于right,所以[left, mid]一定会舍弃元素,避免无限递归
            return findMinValueInRotatingOrderedArray(arr, left, mid);
        }
    }
    // 测试
    public static void main(String[] args) {
        int[] arr = new int[]{5,6,7,7,8,19,21,1,1,2,2,3,4,5,5,5};
        System.out.println(new FindMinValueInRotatingOrderedArray().findMinValueInRotatingOrderedArray(arr));
    }
}
```

