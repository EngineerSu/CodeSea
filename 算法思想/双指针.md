## 双指针

#### 累加和为定值的所有子数组

Q:给一个已经排序的正整数数组arr(无重复元素)和一个数num,求arr累加和为num的所有子数组

A:如果用辅助空间的方法,map的value得是一个List,但是辅助空间没有利用有序这个条件.  用两个指针p1和p2,刚开始分别指向0和1的位置,然后计算它们的sum,如果大了p1++,如果小了p2++.如果等于,则得到了一个满足的子数组.然后p1++,重复之前的过程

```java
public static List<Node> getAllSubArr(int[] arr, int num){
    if(arr == null || arr.length == 0){
        return null;
    }
    
    int p1 = 0;
    int p2 = 0;
    int sum = arr[p1];   
    List<Node> list = new ArrayList<>();
    while(p2 < arr.length){
        if(sum > num){
            if(p1 == p2){
                p1++;
                p2++;
                sum = arr[p2];
            } else {                
                sum -= arr[p1++];
            }
        } else if(sum < num){
            p2++;
            if(p2 == arr.length){
                break;
            }
            sum += arr[p2];
        } else {
            list.add(new Node(p1++,p2));
        }
    }
    
    return list;
}
```

### 蓄水池问题

Q:给一个int数组arr,数组中每个值代表,它的索引位置x=i处有一个高度为arr[i]的木桩,根据数组选择两个木桩,求其最大蓄水量.

E:比如arr = [1,8,6,2,5,4,8,3,7];它的最大蓄水量为49

![1554343774210](../img/蓄水池问题.png)

```
假设选的位置分别是p1,p2.其蓄水量表达式为 (p2-p1) * Math.min(arr[p1], arr[p2])
即蓄水量取决于 他们的距离 和 他们其中较小的值
因此用双指针的思想,一开始就让p1指向第一个位置,p2指向最后一个位置. 每次让arr[p1], arr[p2]其中较小的一个值进行移动,比如arr[p1]<arr[p2],就让p1往右移动,移动过程中如果arr[cur]<=p1,那么一定不会比之前值还大,如果arr[cur]>p1,那么就可能取到新的最大蓄水量值.此时将p1移到cur的位置,重新开始前面的步骤.直到p1>=p2

关键点:双指针从两头开始找蓄水量最大值. 每次移动较小高度的索引位置
```

```java
class Solution {
    public int maxArea(int[] height) {
        if(height == null || height.length < 2){
            return 0;
        }
        
        int p1 = 0;
        int p2 = height.length - 1;
        int max = 0;           
        while(p1 < p2){            
            int smaller = Math.min(height[p1], height[p2]);
            max = Math.max(max, (p2-p1) * smaller);
            if(smaller == height[p1]){
                int cur = p1;
                while(cur < p2 && height[cur] <= height[p1]){
                    cur++;
                }
                p1 = cur;
            } else {
                int cur = p2;
                while(cur > p1 && height[cur] <= height[p2]){
                    cur--;
                }
                p2 = cur;
            }
        }
        
        return max;
    }
}
```

### 