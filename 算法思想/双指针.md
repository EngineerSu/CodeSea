## 双指针

### 目录

* [累加和为定值的所有子数组](#累加和为定值的所有子数组)
* [蓄水池问题](#蓄水池问题)
* [2sum:和为s的两个数字](#2sum:和为s的两个数字)
* [3sum](#3sum)



----

### 累加和为定值的所有子数组

[回到目录](#目录)

Q:给一个已经排序的正整数数组arr(无重复元素)和一个数num,求arr累加和为num的所有子数组

A:如果用辅助空间的方法,map的value得是一个List,但是辅助空间没有利用有序这个条件.  用两个指针p1和p2,刚开始分别指向0和1的位置,然后计算它们的sum,如果大了p1++,如果小了p2++.如果等于,则得到了一个满足的子数组.然后p1++,重复之前的过程

```java
public static List<Node> getAllSubArr(int[] arr, int num){
    if(arr == null || arr.length == 0){
        return null;
    }
    
    int p1 = 0;
    int p2 = 0;
    int sum = arr[p1];   
    List<Node> list = new ArrayList<>();
    while(p2 < arr.length){
        if(sum > num){
            if(p1 == p2){
                p1++;
                p2++;
                sum = arr[p2];
            } else {                
                sum -= arr[p1++];
            }
        } else if(sum < num){
            p2++;
            if(p2 == arr.length){
                break;
            }
            sum += arr[p2];
        } else {
            list.add(new Node(p1++,p2));
        }
    }
    
    return list;
}
```



### 蓄水池问题

[回到目录](#目录)

Q:给一个int数组arr,数组中每个值代表,它的索引位置x=i处有一个高度为arr[i]的木桩,根据数组选择两个木桩,求其最大蓄水量.

E:比如arr = [1,8,6,2,5,4,8,3,7];它的最大蓄水量为49

![1554343774210](../img/蓄水池问题.png)

```
假设选的位置分别是p1,p2.其蓄水量表达式为 (p2-p1) * Math.min(arr[p1], arr[p2])
即蓄水量取决于 他们的距离 和 他们其中较小的值
因此用双指针的思想,一开始就让p1指向第一个位置,p2指向最后一个位置. 每次让arr[p1], arr[p2]其中较小的一个值进行移动,比如arr[p1]<arr[p2],就让p1往右移动,移动过程中如果arr[cur]<=p1,那么一定不会比之前值还大,如果arr[cur]>p1,那么就可能取到新的最大蓄水量值.此时将p1移到cur的位置,重新开始前面的步骤.直到p1>=p2

关键点:双指针从两头开始找蓄水量最大值. 每次移动较小高度的索引位置
```

```java
class Solution {
    public int maxArea(int[] height) {
        if(height == null || height.length < 2){
            return 0;
        }
        
        int p1 = 0;
        int p2 = height.length - 1;
        int max = 0;           
        while(p1 < p2){            
            int smaller = Math.min(height[p1], height[p2]);
            max = Math.max(max, (p2-p1) * smaller);
            if(smaller == height[p1]){
                int cur = p1;
                while(cur < p2 && height[cur] <= height[p1]){
                    cur++;
                }
                p1 = cur;
            } else {
                int cur = p2;
                while(cur > p1 && height[cur] <= height[p2]){
                    cur--;
                }
                p2 = cur;
            }
        }
        
        return max;
    }
}
```



### 2sum:和为s的两个数字

[回到目录](#目录)

Q:在递增排序的数组中找两个数,其和为s,并打印.如果有多对数字和为s,输出任意一对即可.

```
本题就是找两个数拼成s,传统的遍历法是固定一个数,再从左往右找数判断其和是否为s.
这样就没有使用数组有序这个条件,对于有序数组的拼凑问题,用双指针是个很好的选择

指针p1在0位置,指针p2在数组最后的位置,当两个数的和大于s,p2往左移,当两个数和小于s,p1往右移动.达到O(N)
```



### 3sum

[回到目录](#目录)

Q:给定一个数组,在数组中找到三个数的和为0的所有组合(不重复)

```
利用2sum的双指针思想,固定一个数,这个问题就变成了2sum问题. 
首先,对数组进行排序,然后遍历数组,第i个数固定,双指针开始分别指向i+1和arr.length-1的位置.这就是2sum问题
保证没有遗漏:三个数和为0的所有组合中,要么包括arr[i],要么不包括arr[i]. 包括arr[i]的情况在固定arr[i]的时候求出了所有情况,不包括arr[i]的情况在不固定arr[i]的时候求出了所有情况.(因为双指针在固定值的后面)
保证没有重复:
	固定arr[i]求出了所有情况后,固定arr[i+1]时要检查arr[i+1]==arr[i]是否成立,如果成立,则继续往后走,直到arr[i+j]!=arr[i].因为固定arr[i]的所有情况在第一次固定它的时候已经求完了.
	双指针在移动时,也遵循上面的规律.比如目前的sum等于0,(p1,p2)是一对满足的情况,然后p1++,p2--. 同时要保证p1++后的位置和之前的位置值不相等,p2同理,不然就可能会输出重复的可能组合.
```

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        
        List<List<Integer>> res = new LinkedList<List<Integer>>();
        if(nums == null || nums.length < 3){
            return res;
        }
        
        Arrays.sort(nums);
        
        for(int i = 0; i < nums.length-2; i++){ 
            if(i > 0 && nums[i] == nums[i-1]){ // 不重复的第一个保障
                continue;
            }
            int p1 = i + 1;
            int p2 = nums.length-1;
            int sum;
            List<Integer> shot;
            while(p1 < p2){ 
                sum = nums[i] + nums[p1] + nums[p2]; 
                if(sum > 0){
                    p2--; // 不重复的第二个保障
                    while(p2 > p1 && nums[p2] == nums[p2+1]) {
                        p2--;
                    }
                } else if(sum < 0){
                    p1++;
                    while(p1 < p2 && nums[p1] == nums[p1-1]){
                        p1++;
                    }
                } else {
                    shot = new ArrayList<Integer>();
                    shot.add(nums[i]);
                    shot.add(nums[p1]);
                    shot.add(nums[p2]);
                    res.add(shot);
                    p1++;
                    p2--;
                    while(p1 < p2 && nums[p1] == nums[p1-1]){
                        p1++;
                    }   
                    while(p2 > p1 && nums[p2] == nums[p2+1]) {
                        p2--;
                    }                    
                }
            }
        }        
        
        return res;
    }

}
```

