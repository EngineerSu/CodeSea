## 二分查找

### 目录

* [两个有序数组的中位数](#两个有序数组的中位数)
* [数字在排序数组中出现的次数](#数字在排序数组中出现的次数)
* [旋转递增数组查找某个数](#旋转递增数组查找某个数)
* [旋转有序数组的最小值求解](#旋转有序数组的最小值求解)



----

### 二分查找的边界问题

二分查找的一般步骤是根据`mid = (left + right) / 2`, 然后根据arr[mid]大小比较, 决定下一个查找区间是在mid左边, 还是mid右边, 即一般是一个递归过程, 所以需要注意下一个区间边界值的选取 以及 递归终止条件的判断.

如果已知在判断条件下, mid处一定不会是击中值, 那么下一个区间边界就是[left, mid-1] 或 [mid+1, right]

三个值时, mid取中间, 两个值时, mid取左边. 所以如果有[mid, right]的判断区间, 递归终止条件需要有left + 1 == right. 即两个值时就需要终止, 不然可能会存在一直两值无限递归





### 两个有序数组的中位数

[回到目录](#目录)

**子问题:两个有序数组第k小的数**

要求主问题的时间复杂度是O(log(M+N)).假设在子问题解决的基础上,调用子问题的函数就可以解决主问题. 假设两个有序数组的长度分别是m, n, 找第(m+n+1)/2 和 (m+n+2)/2 小的数, 它们的平均数就是中位数(无论两个有序数组总长度是奇数还是偶数)

如何求两个有序数组第k小的数? 核心思想是每次排除k/2个数

每次分别找两个有序数组第k/2小的数假设为arr1[k/2] 和 arr2[k/2], 比较它们的大小. 若`arr1[k/2] < arr2[k/2]`, 则第k小的数肯定不会在arr1的0~k/2中出现, 反之不会在arr2的0~k/2中出现, 所以每次可以排除k/2个数. 用两个位置指针记录两个数组排除数后的位置, 则可以递归求解.

当然上面只讲了最普通的情况, 还有`arr1[k/2] == arr2[k/2]`的可能, 说明第k小的数就是arr1[k/2]. 还有可能k/2已经超过了arr1的长度, 此时直接让arr2舍弃k/2个数即可.

```java
public static int findKthNumInTwoSortedArray(int[] arr1, int[] arr2, int k) {
    return findKthNumInTwoSortedArray(arr1, arr2, k, 0, 0);
}
private static int findKthNumInTwoSortedArray(int[] arr1, int[] arr2, int k, int p1, int p2) {
    // 非递归终止条件,而是一开始就比较的条件
    // 因为arr1,arr2并不随递归改变
    if (null == arr1 || arr1.length == 0) {
        // 直接在arr2中寻找第k大的数
        return findKthNumInSortedArray(arr2, k);
    } else if (null == arr2 || arr2.length == 0) {
        return findKthNumInSortedArray(arr1, k);
    } else if (k > arr1.length + arr2.length) {
        return -1;
    }
    // 下面才是递归终止条件
    if (p1 == arr1.length) {
        // arr1在上轮淘汰中把自己所有数都淘汰完了
        // 所以取arr2从p2位置开始算的第k大的数
        return findKthNumInSortedArray(arr2, k, p2);
    } else if (p2 == arr2.length) {
        return findKthNumInSortedArray(arr1, k, p1);
    } else if (k == 1) {
        // k等于1可以直接比较不用再递归
        return Math.min(arr1[p1], arr2[p2]);
    }
    // 递归情况1:某数组往前走pi步时出界,则直接舍弃另外一个数组k/2的数
    if (p1 + k / 2 - 1 >= arr1.length) {
        return findKthNumInTwoSortedArray(arr1, arr2, k - k / 2, p1, p2 + k / 2);
    } else if (p2 + k / 2 - 1 >= arr2.length) {
        return findKthNumInTwoSortedArray(arr1, arr2, k - k / 2, p1 + k / 2, p2);
    }
    // 递归情况2:比较走pi步后谁小,谁舍弃(p真的移动)
    if (arr1[p1 + k / 2 - 1] < arr2[p2 + k / 2 - 1]) {
        return findKthNumInTwoSortedArray(arr1, arr2, k - k / 2, p1 + k / 2, p2);
    } else if (arr1[p1 + k / 2 - 1] == arr2[p2 + k / 2 - 1]) {
        // 等于就击中啦!!
        return arr1[p1 + k / 2 - 1];
    } else {
        return findKthNumInTwoSortedArray(arr1, arr2, k - k / 2, p1, p2 + k / 2);
    }
}
private static int findKthNumInSortedArray(int[] arr, int k, int p) {
    if (null == arr || arr.length == 0 || p + k > arr.length) {
        return -1;
    }
    return arr[p + k - 1];
}
private static int findKthNumInSortedArray(int[] arr, int k) {
    if (null == arr || arr.length == 0 || k > arr.length) {
        return -1;
    }
    return arr[k - 1];
}
```



### 数字在排序数组中出现的次数

[二分查找目录](#目录)

Q: 给一个排序数组,问其中某个数在数组中出现的次数

A: 分别用二分法寻找这个数出现的左边界和有边界, 注意这个数可能不存在. 

```java
public int findKTimesInOrderedArray(int[] arr, int num) {
    int left = findLeftBorder(arr, num, 0, arr.length - 1);
    // 没有左边界表明数据不存在提前返回
    if (left == -1) {
        return 0;
    }
    int right = findRightBorder(arr, num, 0, arr.length - 1);
    // 不存在会提前返回,所有到这里说明有边界一定存在
    return right - left + 1;
}
private int findRightBorder(int[] arr, int num, int left, int right) {
    if (left + 1 == right) {
        if (arr[right] == num) {
            return right;
        } else if (arr[left] == num) {
            return left;
        } else {
            return -1;
        }
    } else if (left == right) {
        return arr[left] == num ? left : -1;
    }
    int mid = (left + right) / 2;
    if (arr[mid] == num) {
        return findRightBorder(arr, num, mid, right);
    } else if (arr[mid] > num) {
        return findRightBorder(arr, num, left, mid - 1);
    } else {
        return findRightBorder(arr, num, mid + 1, right);
    }
}
private int findLeftBorder(int[] arr, int num, int left, int right) {
    if (left > right) {
        return -1;
    } else if (left == right) {
        return arr[left] == num ? left : -1;
    }
    int mid = (left + right) / 2;
    if (arr[mid] == num) {
        return findLeftBorder(arr, num, left, mid);
    } else if (arr[mid] > num) {
        return findLeftBorder(arr, num, left, mid - 1);
    } else {
        return findLeftBorder(arr, num, mid + 1, right);
    }
}
```



### 旋转递增数组查找某个数

[二分查找目录](#目录)

Q：给定一个数组arr，它是由一个递增的数组旋转得到，比如[4,5,6,7,0,1,2]，假设这个数组没有重复的数字，给定一个num，返回它在这个数组中的index，如果没有返回-1，要求时间复杂度O(logN)

A：在[left， right]区间中寻找mid，如果arr[mid]>arr[right]，表明[left, mid-1]是有序递增部分，反之[mid+1, right]是有序递增部分，在有序递增部分确定有没有num存在是很简单的，如果不存在就去另一部分寻找。

```java
public static int searchNumInRotatedSortedArray(int[] arr, int num) {
    if (null == arr || arr.length == 0) {
        return -1;
    }
    return searchNumInRotatedSortedArray(arr, num, 0, arr.length - 1);
}
private static int searchNumInRotatedSortedArray(int[] arr, int num, int left, int right) {
    // 此方法的参数异常在调用方已检查和约定
    if (left == right) {
        return arr[left] == num ? left : -1;
    }
    int mid = (left + right) >> 1;
    if (arr[mid] > arr[right]) {
        // 左边是递增区间
        if (num >= arr[left] && num <= arr[mid]) {
            // 只用在左边二分法寻找
            return searchNumInSortedArray(arr, num, left, mid);
        } else {
            return searchNumInRotatedSortedArray(arr, num, mid + 1, right);
        }
    } else {
        // 右边是递增区间
        if (num <= arr[right] && num > arr[mid]) {
            return searchNumInSortedArray(arr, num, mid + 1, right);
        } else {
            return searchNumInRotatedSortedArray(arr, num, left, mid);
        }
    }
}
// 有序数组的普通二分法
private static int searchNumInSortedArray(int[] arr, int num, int left, int right) {
    if (left == right) {
        return num == arr[left] ? left : -1;
    } else if (left > right) {
        return -1;
    }
    int mid = (left + right) >> 1;
    if (num < arr[mid]) {
        return searchNumInSortedArray(arr, num, left, mid - 1);
    } else if (num == arr[mid]) {
        return mid;
    } else {
        return searchNumInSortedArray(arr, num, mid + 1, right);
    }
}
```



### 旋转有序数组的最小值求解

[二分查找目录](#目录)

Q: 将有序数组前面0~i位移动到原数组的末尾,称为数组的旋转.给一个旋转数组,求其最小值

A: 若`arr[left] < arr[right]`, 表明[left, right]之间依旧是非降序排序, 所以最小值就是arr[left]. 若`arr[left] >= arr[right]`, 求left和right处的中间位置mid, 先来看一种特殊情况: `arr[left] == arr[mid] && arr[mid] == arr[right]`时, 是无法判断下一步应该在mid左边还是右边寻找最小值, 这种情况只能遍历[left, right]求最小值. 如果不是这种情况, 若`arr[mid] >= arr[left]`, 那么表明在[left, mid]之间是非降序排列的, 最小值可以在[mid+1, right]中寻找, 反之最小值在[left, mid]之中寻找.

与[旋转递增数组查找某个数](#旋转递增数组查找某个数)思想基本一样, 都是通过arr[mid]和边界值进行比较, 进而判断左边或右边是有序的, 然后在有序空间里尝试求解问题, 不能求解就递归到另一边. 区别是本题数字可能是重复的, 所以当arr[mid]=arr[left]=arr[right]情况出现时, 就不能判断左边还是右边有序了

```java
public class FindMinValueInRotatingOrderedArray {
    // Q:对于一个非降序的有序数组,将其0~i位置旋转到有序数组的末尾,求旋转后数组的最小值
    // A:遍历的时间复杂度是O(N),这里可以用二分法达到O(logN)的时间复杂度

    public Integer findMinValueInRotatingOrderedArray(int[] arr) {
        if (null == arr || 0 == arr.length) {
            return null;
        }
        return findMinValueInRotatingOrderedArray(arr, 0, arr.length - 1);
    }

    /*
     * arr[left] < arr[right]:是有序部分,最小值即arr[left]
     * arr[left] >= arr[right] && arr[left] == arr[mid] == arr[right]:无法用二分法判断最小值在mid左边还是右边,只能遍历
     * arr[left] >= arr[right] && arr[mid] <= arr[right]:最小值在mid左边
     * arr[left] >= arr[right] && arr[mid] >= arr[left]:最小值在mid右边
     * */
    private Integer findMinValueInRotatingOrderedArray(int[] arr, int left, int right) {
        // 如果只有一个元素,或者左边<右边表示整个递增即击中最小值
        if (left == right || arr[left] < arr[right]) {
            return arr[left];
        }
        int mid = (left + right) / 2;
        // 左中右都相等时无法二分判断
        if (arr[left] == arr[mid] && arr[mid] == arr[right]) {
            int min = arr[left];
            while (left++ < right) {
                if (min > arr[left]) {
                    min = arr[left];
                }
            }
            return min;
        }
        if (arr[mid] >= arr[left]) {
            // 不小于左边时,二分判断在右边
            // 因为两个元素时,mid其实就是left,所以判断在右边的时候如果用[mid, right]可能会无限递归
            return findMinValueInRotatingOrderedArray(arr, mid + 1, right);
        } else {
            // 否则二分判断在左边
            // 因为即使两个元素时,mid也不会等于right,所以[left, mid]一定会舍弃元素,避免无限递归
            return findMinValueInRotatingOrderedArray(arr, left, mid);
        }
    }
    // 测试
    public static void main(String[] args) {
        int[] arr = new int[]{5,6,7,7,8,19,21,1,1,2,2,3,4,5,5,5};
        System.out.println(new FindMinValueInRotatingOrderedArray().findMinValueInRotatingOrderedArray(arr));
    }
}
```

