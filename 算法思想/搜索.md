## 搜索

### 矩阵中的路径

Q:给定一个字符二维矩阵和一个字符串,判断这个字符串是不是矩阵中的一条路径,上下左右都可以走,走过的路不能重复走

```
回朔法的业务逻辑:遍历矩阵中的点,当遇到和字符串第一个字符匹配的时候,开启匹配方法:从第一个位置上下左右走,如果可以走继续走,如果不可以走,准备回退. 这种回溯需要一个和矩阵大小一样的boolean数组,标志着已经走过的路,不能回走.并且在行走时,需要用stack将路线压栈,回退时,要将栈顶的坐标做一个标记,让它知道回退后不能再往相同方向走.
```

```java
// Q1
public static boolean isStrPathInMatrix(char[][] mat, String str) {

    if(mat == null || mat[0] == null || mat[0].length == 0 || str == null || str.length() == 0) {
        return false;
    }

    int row = mat.length;
    int column = mat[0].length;

    for(int i = 0; i < row; i++) {
        for(int j = 0; j < column; j++) {
            if(mat[i][j] == str.charAt(0) && findRightPath(mat, i, j, row, column, str)) 
                    return true;
        }
    }

    return false;
}

private static boolean findRightPath(char[][] mat, int i, int j, int row, int column, String str) {

    boolean[][] isTraversed = new boolean[row][column];
    isTraversed[i][j] = true;

    Stack<Coordinate> stack = new Stack<Coordinate>();
    stack.push(new Coordinate(i, j));
    int index = 1; // 表示下一个正在匹配的字符
    while(!stack.isEmpty() && index < str.length()) {
        int curRow = stack.peek().row;
        int curColumn = stack.peek().column;
        if(curRow + 1 < row && mat[curRow+1][curColumn] == str.charAt(index) && stack.peek().down && !isTraversed[curRow+1][curColumn]) { // 表示和当前点的右边第一次匹配上
            stack.peek().down = false; // 如果第一次匹配上,没走成功,就不会再走这一条路
            index++;
            stack.push(new Coordinate(curRow + 1, curColumn));
            isTraversed[curRow + 1][curColumn] = true; // 下一步不能回头走
            continue;
        }
        if(curRow - 1 >= 0 && mat[curRow-1][curColumn] == str.charAt(index) && stack.peek().up && !isTraversed[curRow-1][curColumn]) {
            stack.peek().up = false; 
            index++;
            stack.push(new Coordinate(curRow - 1, curColumn));
            isTraversed[curRow - 1][curColumn] = true;
            continue;
        }
        if(curColumn + 1 < column && mat[curRow][curColumn+1] == str.charAt(index) && stack.peek().right && !isTraversed[curRow][curColumn+1]) {
            stack.peek().right = false; 
            index++;
            stack.push(new Coordinate(curRow, curColumn+1));
            isTraversed[curRow][curColumn + 1] = true;
            continue;
        }
        if(curColumn - 1 >= 0 && mat[curRow][curColumn-1] == str.charAt(index) && stack.peek().left && !isTraversed[curRow][curColumn-1]) {
            stack.peek().left = false; 
            index++;
            stack.push(new Coordinate(curRow, curColumn-1));
            isTraversed[curRow][curColumn - 1] = true;
            continue;
        }

        // 上下左右都寻找失败,需要回退
        curRow = stack.peek().row;
        curColumn = stack.peek().column;
        isTraversed[curRow][curColumn] = false; // 回退之后可以有可能再走这条路
        stack.pop();
    }

    if(stack.isEmpty()) {
        return false;
    } else {
        return true;
    }

}

// stack压栈时的坐标,对回退的路线设置false标志,以便回退后不再尝试失败过的路线
public static class Coordinate{
    int row;
    int column;

    // 表示当前节点的上下左右是否能走,true表示可以走
    boolean up = true;
    boolean down = true;
    boolean left = true;
    boolean right = true;
    public Coordinate(int row, int column) {
        super();
        this.row = row;
        this.column = column;
    }
}
```

