## 递归

### 目录

**概念:**

* [Master公式](#Master公式)

**其它:**

* [汉诺塔问题](#汉诺塔问题)
* [打印字符串的所有子序列](#打印字符串的所有子序列)
* [打印字符串的所有全排列](#打印字符串的所有全排列)
* [括号匹配](#括号匹配)
* [括号组合](#括号组合)
* [Combination Sum](#Combination Sum)
* [复制粘贴字符串](#复制粘贴字符串)
* [正则表达式匹配](#正则表达式匹配)



### Master公式

[回到目录](#目录)

master公式是一个时间复杂度的递推公式,指的是当前规模(N)的任务拆分成若干个(a)**相同规模**(N/b)的子任务,每次任务还需进行一个复杂度为O(N^d^)的操作.

![](../img/master公式.jpg)



### 汉诺塔问题

[回到目录](#目录)

Q：三个杆,有n个盘(小压大的顺序),要求将这n个盘从最左杆移动到最右杆(保持相同的顺序),要求移动过程中所有杆上的盘都只能小压大,不能大压小

```java
// 汉诺塔的递归非常美 -> 打印移动方法,返回总的移动步数
public static int movePlates(int N, String from, String help, String to) {

    if(N == 1) {
        System.out.println(from + "->" + to);
        return 1;
    }

    int step1 = movePlates(N-1, from, to, help);
    System.out.println(from + "->" + to);
    int step2 = movePlates(N-1, help, from, to);

    return step1 + 1 + step2;
}

public static void main(String[] args) {

    int step = movePlates(10, "A", "B", "C");
    System.out.println("steps: " + step);

}
```



### 打印字符串的所有子序列

[回到目录](#目录)

Q：子序列不是子串，不用保证原字符串中连续的字符在子序列中还保持连续

A：2^n^的递归实现。假设字符串长度为N,则相当于有N个空位,每个位置都有两个选项,即打印或者不打印该位置的字符,所以知道它的子字符串有2^N种,因为每一种都需要打印,所以这个时间复杂度是优化不了的.

```java
private static void print(String str, int index, String res) {

    if(index == str.length()) {
        if(!res.equals("")) {
            System.out.println(res);
        }
        return;
    }

    print(str, index + 1, res);
    print(str, index + 1, res + str.charAt(index));
}
```



### 打印字符串的所有全排列

[回到目录](#目录)

Q：子序列可以不包含字符串中的某些字符，而全排列则是包含所有的字符，只是顺序不一样

A：有N!种可能排列

```java
// n!的递归写法
public static int print(String resource, int index, String rest, String last) {

    if(resource == null || resource.length() == 0) {
        return 0;
    }

    int res = 0;
    if(index == resource.length()) {
        System.out.println(last);
        res++;
        return res;
    }

    int l_rest = rest.length();
    String rest_temp;
    String last_temp;
    for(int i = 0; i < l_rest; i++) {
        rest_temp = rest.substring(0,i) + rest.substring(i+1,l_rest);
        last_temp = last + String.valueOf(rest.charAt(i));
        res += print(resource, index + 1, rest_temp, last_temp);
    }

    return res;

}
```



### 括号匹配

[回到目录](#目录)

Q:给一个字符串,其中可以包含字符'()[]{}',试判断这个字符串是否满足符号匹配

```
用栈的结构,判断的时候用switch() case,注意每个case都要break,不然一旦满足就会执行后面所有情况
逻辑:遇到左括号压栈,遇到右括号,栈顶如果不匹配直接return false;栈顶匹配就弹出栈顶,继续遍历
遍历完后,如果栈是空的,表明匹配
```



### 括号组合

[回到目录](#目录)

Q:给一个整数n,代表有n对'()',问给出所有符合括号匹配的组合字符串

```java
// A1:递归思想,将'('看作+1,')'看作-1. 递归深度2*n,base-case:index到底&&sum==0就是符合要求的字符串
// 优点:只用了一个char数组,不用字符串拼接,避免了频繁创建字符串对象
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> list = new ArrayList<>();
        if( n == 0){
            return list;
        }
        
        int index = 0;
        int sum = 0;
        char[] res = new char[2*n];
        
        process(0, 0, res, list);
        
        return list;
    }
    
    public void process(int index, int sum, char[] res, List<String> list){
        if(index == res.length){
            if(sum == 0){
                list.add(new String(res));
            }
            return;
        }
        
        if(sum == 0){
            res[index] = '(';
            process(index+1, sum+1, res, list);
        } else { // 只可能是大于0的情况
            res[index] = '(';
            process(index+1, sum+1, res, list);
            res[index] = ')';
            process(index+1, sum-1, res, list);
        }
    }
}
```

```java
// A2:递归. left和right记录左括号和右括号剩余的数量. 如果左边剩余的多余右边,return false
// 优点:看起来很简洁, 缺点:拼接字符串产生很多多余内存
public class Solution{
    public static List<String> getList(int n){
        List<String> list = new ArrayList<>();
        if(n == 0){
            return null;
        }
        
        process(n, n, "", list);
        
        return list
    }
    
    public static void process(int left, int right, String str, List<String> list){
        if(left < 0 || right < 0 || left > right){
            return;
        }
        if(left == 0 && right == 0){
            list.add(str);
            return;
        }
        
        process(left-1, right, str+'(', list);
        process(left, right-1, str+')', list);
    }
}
```



### Combination Sum

[回到目录](#目录)

Q：给一个数组arr，数组内无重复的数字，再给一个整数num，求所有能构成num的数字组合，数组中同一个数可以重复使用。

E：arr=[2,3,6,7]，num=7。输出为[[7], [2,2,3]]

A：首先将数组排序，然后从最大的数开始遍历，大于num的数可以直接跳过。每个数再进行递归遍历，遍历次数是0~num/arr[index]次，即这个数在组合中最少出现0次，最多出现num/arr[index]次。如下，可以用num进行减的形式，就节约了一个变量sum。

````java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if(candidates==null || candidates.length==0){
            return null;
        }
        
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(candidates);     
        List<Integer> son = new ArrayList<>();
        process(candidates, target, candidates.length-1, 0, list, son);
        return list;
    }
    
    private static void process(int[] arr, int num, int index, int sum, List<List<Integer>> list, List<Integer> son){
        if(sum == num){
            List<Integer> temp = new ArrayList<Integer>(son);
            // Collections.sort(temp);
            list.add(temp);
            return;
        } else if(sum>num || index==-1){
            return;
        }
        
        int times = num / arr[index];
        for(int i=0; i<=times; i++){
            int j = i;
            while(j-- > 0){
                son.add(arr[index]);                
            }
            process(arr, num, index-1, sum+i*arr[index], list, son);
            j = i;
            while(j-- > 0){
                son.remove(son.size()-1);                
            }
        }
    }
}
````



### 复制粘贴字符串

[回到目录](#目录)

[650. 2 Keys Keyboard](https://leetcode.com/problems/2-keys-keyboard/description/)

Q: 最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴

```
Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
```

A: 粘贴本质就是翻倍, 所以对于素数, 没有因子, 它只能一直复制粘贴, 它的次数就是素数本身. 对于非素数, 假设`n = i * j` 使i取最小, 则j最大, 将j个A复制i次, 即可得到n个A, 这样的次数是最少的:`dp[n] = i*dp[j]`, 而求dp[j]时也是这样去求,  有点贪心的感觉. 

````java
class Solution {
    public int minSteps(int n) {
        if(n == 1){
            return 0;
        }
        
        for(int i=2; i<=Math.sqrt(n); i++){
            if(n%i == 0){
                return minSteps(n / i) + i; // n/i个A出来后,复制+i-1次粘贴即可得到n个A
            }
        }
        
        return n; // 素数base
    }
}
````

S: 这里虽然用了递归, 但是没有重复计算



### 正则表达式匹配

[递归目录](#目录)

Q: 给定字符串str和exp, str中不包含'.'和'*', exp中可能包含'.'和' *', 其中'.'可以匹配一个任意数量的字符,' X *'可以匹配0个或若干个X. *不能是exp的首字符,也不能有连续的两个 *. 给定str和exp,判断exp是否能匹配str

如: .*可以匹配任意字符串 `.a *`可以匹配至少含有一个字符的任意字符串

```
核心判断条件  ei位置后面是不是'*'!!!
如果没有*: 那么必须让当前si位置能和ei位置匹配上,才能si++,ei++, 继续判断
如果有*: 只要si位置能和ei位置匹配，就有多了一种匹配的可能（si++）。如果这个*匹配的所有可能如果都失败,那只能继续往下:si跳到第一个和ei不匹配的位置,ei跳过这个*，然后重新开始匹配. 
	
第二种情况如下图:part1和part2匹配有5种可能:0~4个A都有可能
	part1中0个A和part2匹配, part1中从第一个A开始 与 part2后面的匹配 (1)
	part1中1个A和part2匹配, part1中从第二个A开始 与 part2后面的匹配
	part1中2个A和part2匹配, part1中从第三个A开始 与 part2后面的匹配
	part1中3个A和part2匹配, part1中从第四个A开始 与 part2后面的匹配
	part1中4个A和part2匹配, part1后从B开始 与 part2后面的匹配 (5)
```

![1563543410406](img/递归/1563543410406.png)

```
// 动态规划思想
从这个递归中可以看到,其依赖与process(str, exp, si+1, ei+1) 和 process(str, exp, si, ei+2)
即以si和ei做一个二维结果表,(0,0)点是要求的结果点,其中所有的点都依赖于右下方的结果点
所以利用base-case从右下方开始求起,逐渐求到(0,0),就是一个动态规划
```

```java
class Solution {
    public boolean isMatch(String s, String p) {
        if(s == null || p == null){
            return false;
        } 

        return process(s, p, 0, 0);
    }

    public static boolean process(String str, String exp, int si, int ei){
        if(ei == exp.length()){
            return si == str.length();
        }

        // ei位置没有后一个元素 或 后一个元素不是 '*'
        if(ei+1 == exp.length() || exp.charAt(ei+1) != '*'){ 
            return si != str.length() && (str.charAt(si)==exp.charAt(ei) || exp.charAt(ei)=='.') && process(str, exp, si+1, ei+1);
        }

        // 继续执行,表明ei位置不是最后一个元素 且 ei+1的位置是'*'
        // 然后根据str和exp的元素决定它能有多少种匹配可能
        while(si != str.length() && (str.charAt(si) == exp.charAt(ei) || exp.charAt(ei)=='.')){
            if(process(str, exp, si, ei+2)){
                return true;
            }
            si++;
        }

        // 走到这里说明*匹配的所有可能都失败了,这里包含了多种可能:
        // 1.ei+1位置是'*',但是ei位置的字符和si位置的字符不匹配,即这个*匹配数量为0
        // 2.ei+1位置是'*',将si位置开始所有与ei位置相等的值都匹配了,即这个*匹配数量达到了最大值
        // 3.si位置已经到了str.length(),但是因为ei一直是X*的模式,所以可以继续到这里
        return process(str, exp, si, ei+2); 

    }
}
```

