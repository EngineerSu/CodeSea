## 动态规划

递归和动态规划的特点都是，将大问题化成小问题去求解，只不过动态规划会存储中间的过程结果，因此避免了很多的重复计算，时间复杂度大大降低。

### 目录

* [斐波那契数列](#斐波那契数列)
* [矩阵路径](#矩阵路径)
* [数组的子数组](#数组的子数组)
* [数组的子序列](#数组的子序列)
* [字符串编辑](#字符串编辑)
* [其它](#其它)
* [股票交易系列问题](#股票交易系列问题)
* [背包问题](#背包问题)

### 斐波那契数列

[动态规划总目录](#目录)

* [爬楼梯](#爬楼梯)
* [强盗抢劫](#强盗抢劫)
* [强盗抢劫-环形街区](#强盗抢劫-环形街区)
* [母牛生产](#母牛生产)

#### 爬楼梯

[70. Climbing Stairs(Easy)](https://leetcode.com/problems/climbing-stairs/description/)

Q: 有N阶楼梯, 每次只能上一阶或两阶, 问一共有多少种走法?

A: 假设dp[i]表示上到第i阶的时候, 有dp[i]种走法, 那么可以得到递推公式:

`dp[i] = dp[i-1] + dp[i-2]`

即到达第i阶楼梯的时候, 可以是走一阶到达, 也可能是走两阶到达.dp[n]就是答案

```java
class Solution {
    public int climbStairs(int n) {
        if(n < 3){
            return n;
        }
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i=3; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[n];
    }
}
```

S: 以上初始化了一个长度为n+1长度的数组, 是为了将dp的下标i表示为楼梯的数量, 便于理解.

**优化空间复杂度**

从递推公式可以看出, 每个dp只依赖其前两个连续的值, 因此用两个变量即可存储前面的信息, 而不用数组. 因此可以将空间复杂度从O(N)优化到O(1)

````java
class Solution {
    public int climbStairs(int n) {
        if(n < 3){
            return n;
        }        
        int pre1 = 1;
        int pre2 = 2;
        int cur = 0;
        for(int i=3; i<=n; i++){
            cur = pre1 + pre2;
            pre1 = pre2;
            pre2 = cur;
        }
        
        return cur;
    }
}
````



#### 强盗抢劫

[198. House Rubber(Easy)](https://leetcode.com/problems/house-robber/description/)

Q: 抢劫一排住户, 但是不能抢劫相邻住户, 已知住户数量为n, 和住户财产int数组nums, 求最大抢劫财产

A: 用dp[i]表示抢劫到第i住户时能获取的最大抢劫财产, 递推公式为

`dp[i] = max{dp[i-1], dp[i-2]+nums[i]}`

它要么是抢劫了第i-1家后的财产, 要么是抢劫了第i-2家后的财产, 加上目前抢劫第i家的财产. 答案为dp[n]

```java
class Solution {
    public int rob(int[] nums) {
        if(nums==null || nums.length==0){
            return 0;
        } else if(nums.length == 1){
            return nums[0];
        } else if(nums.length == 2){
            return Math.max(nums[0], nums[1]);
        }
        
        int pre1 = nums[0];
        int pre2 = Math.max(nums[0], nums[1]);
        int cur = 0;
        for(int i=2; i<nums.length; i++){ // 从第三家开始抢到第i家
            cur = Math.max(pre2, pre1+nums[i]);
            pre1 = pre2;
            pre2 = cur;
        }
        
        return cur;
    }
}
```



#### 强盗抢劫-环形街区

[213. House Robber II(Medium)](<https://leetcode.com/problems/house-robber-ii/description/>)

Q: 用户不再是一排, 而是一个环, 即nums数组的最后一个元素和第一个元素是相邻的

A: 即最后一个住户为L, 第一个住户为F, L和F有三种可能: L被抢,F没被抢; L没被抢,F被抢; L和F都没被抢. 即它们之中至少一个没被抢, 假设L没被抢, 那么问题就相当于求`0~n-2`范围内的条形街区, 假设F没被抢,那么问题就相当于求`1~n-1`范围内的条形街区, 在两者之中取一个最大值即可.

````java
class Solution {
    public int rob(int[] nums) {
        if(nums==null || nums.length==0){
            return 0;
        }
        
        int n = nums.length;
        if(n == 1){
            return nums[0];
        }
        
        return Math.max(rob(nums, 0, n-2), rob(nums, 1, n-1));
    }
    
    private static int rob(int[] nums, int first, int last){
        int pre1 = 0;
        int pre2 = 0;        
        
        for(int i=first; i<=last; i++){
            int cur = Math.max(pre1, pre2+nums[i]);
            pre2 = pre1;
            pre1 = cur;
        }
        
        return pre1;
    }
}
````



#### 母牛生产

Q: 已知有一头成熟母牛,每年都可以生一头小牛,小牛从出生那年开始算, 三年后开始也会每年生一头牛.求N年后有多少头牛

A：用dp[i]表示第i年牛的数量, 它的递推式为

`dp[i] = dp[i-1] dp[i-3]`

即今年牛的数量由去年"老牛" + 今年"新生牛"组成, 而今年所有"新生牛"的数量等于三年前所有牛的数量.

```java
// 递归写法
int[] init = new int{1,2,3};
public static int getCattles(int n){
    if(n < 4){
        return init[n];
    }
    
    return getCattles(n-1) + getCattles(n-3);
}

// 动态规划的顺序代码
int[] values = new int[N];
values[0] = 1;
values[1] = 2;
values[2] = 3;
for(int i = 0; i < N; i++){
    values[i] = values[i-1] + values[i-3]; // 区别于前面的递推,这里是按顺序求,不用递归
}
return values[i-1];
```



### 矩阵路径

[动态规划总目录](#目录)

* [矩阵的最小路径和](#矩阵的最小路径和)
* [矩阵的总路径数](#矩阵的总路径数)

#### 矩阵的最小路径和

[64. Minimum Path Sum(Medium)](https://leetcode.com/problems/minimum-path-sum/description/)

Q：给一个二维数组grid, 一个点从左上角移动到右下角, 只能右移和下移, 求经过的最短路径和

A：`do[i][j]`表示grid的第i行第j列, 走到右下角的最短路径和. 它的递推公式为:

`dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1]) + grid[i][j]`

即要么从下边走, 要么从右边走, 结果就是`dp[0][0]`, 需要从后往前求解. 而在最后一行或最后一列的元素都只有一种走法,因此`dp[n-1][j]和dp[i][n-1]`是可以求的已知条件

````java
class Solution {
    public int minPathSum(int[][] grid) {
        if(grid==null || grid.length==0 || grid[0]==null || grid[0].length==0){
            return 0;
        }
        
        int row = grid.length;
        int col = grid[0].length;
        if(row == 1){
            int res = 0;
            for(int i=0; i<col; i++){
                res += grid[0][i];
            }
            return res;
        }
        if(col == 1){
            int res = 0;
            for(int i=0; i<row; i++){
                res += grid[i][0];
            }
            return res;
        }        
        
        int[][] dp = new int[row][col];
        
        // 初始化
        dp[row-1][col-1] = grid[row-1][col-1];
        for(int i=col-2; i>=0; i--){
            dp[row-1][i] = grid[row-1][i] + dp[row-1][i+1];
        }
        for(int i=row-2; i>=0; i--){
            dp[i][col-1] = grid[i][col-1] + dp[i+1][col-1]; 
        }
        
        // 递推关系式
        for(int i=row-2; i>=0; i--){
            for(int j=col-2; j>=0; j--){
                dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1]) + grid[i][j];
            }
        }
        
        return dp[0][0];
    }
}
````

**空间复杂度优化**: 从递推公式可以看出, 当前的最优值取决于右边和下边, 而求二维dp时是求了一行, 再求上一行, 求每行时, 是从后往前求的. 所以可以将dp降为一维, 递推式变为:

`dp[j] = Math.min(dp[j], dp[j+1]) + grid[i][j]`

式中第一个dp[j]其实表示的是`dp[i-1][j]`, 即还没有更新的dp[j], 而dp[j+1]因为在求dp[j]之前已经求过了, 所以它表示的是`dp[i][j+1]`, 就这样实现了空间复杂度从二维到一维的降维. 这样做的本质是"覆盖式"存储, 每次存一个dp, 其实就丢掉了之前求出来但是对后面无帮助的dp.

````java
class Solution {
    public int minPathSum(int[][] grid) {
        if(grid==null || grid.length==0 || grid[0]==null || grid[0].length==0){
            return 0;
        }
        
        int row = grid.length;
        int col = grid[0].length;
        if(row == 1){
            int res = 0;
            for(int i=0; i<col; i++){
                res += grid[0][i];
            }
            return res;
        }
        if(col == 1){
            int res = 0;
            for(int i=0; i<row; i++){
                res += grid[i][0];
            }
            return res;
        }        
        
        int[] dp = new int[col];
        
        // 初始化    
        dp[col-1] = grid[row-1][col-1];
        for(int i=col-2; i>=0; i--){
            dp[i] = grid[row-1][i] + dp[i+1];
        }
        
        // 递推关系式
        for(int i=row-2; i>=0; i--){
            dp[col-1] += grid[i][col-1]; // dp的最后一列直接更新
            for(int j=col-2; j>=0; j--){
                dp[j] = Math.min(dp[j], dp[j+1]) + grid[i][j];
            }
        }
        
        return dp[0];
    }
}
````



#### 矩阵的总路径数

[Unique Paths(Medium)](https://leetcode.com/problems/unique-paths/description/)

Q: 统计从矩阵的左上角移动到右下角的可能路径总数, 要求只能往右移或下移.

A: 假设这个矩阵为MxN维度, 如果没有其他条件, 可以用排列组合来求, 即在M+N-2的总步数中, 选出M-1步往右走,即答案为C(M+N-2, M-1). 但是如果有其他条件, 比如矩阵中某些位置有"石头", 即不能通行. 此时用`dp[i][j]`表示从第i行j列走到右下角的可能路径总数.它的递推式为:

`dp[i][j] = dp[i][j+1] + dp[i+1][j] (grid[i][j]==0, 即当这个位置没有"石头"时)`
`dp[i][j] = 0 (grid[i][j]!=0, 即当这个位置有"石头"时,通过它不能走到右下角)`

````java
class Solution {
    public int uniquePaths(int m, int n) {
        if(m==1 || n==1){
            return 1;
        }
        
        long res = 1;
        for(int i=1; i<=m-1; i++){
            res = res * (i+n-1) / i;
        }
        
        return (int)res;
    }
}
````



### 数组的子数组

[动态规划总目录](#目录)

* [等差递增子数组个数](#等差递增子数组个数)
* [异或和为0的子数组](#异或和为0的子数组)

#### 等差递增子数组个数

[413. Arithmetic Slices(Medium)](https://leetcode.com/problems/arithmetic-slices/description/)

Q: 给一个int数组, 如果其某个子数组完全成等差数列, 称为一个等差递增子区间, 求这样的区间个数

A: dp[i]表示以第i个数结尾的递增子区间, dp[i]中所有的子区间必须满足`A[i] - A[i-1] = A[i-1] - A[i-2]`, 如果不满足, 则表明dp[i]=0, 因此dp[i]的递推关系式为:

`dp[i] = dp[i-1] + 1 (当满足A[i] - A[i-1] = A[i-1] - A[i-2])`
`dp[i] = 0 (当不满足)`

因为满足时, 所有的dp[i-1]子区间再连上一个A[i]即满足dp[i]的要求, 还会新增一个子区间:`A[i-2] A[i-1] A[i]`. 因此有上面递推式. 所有等差的递增子区间是所有dp[i]的和

```java
class Solution {
    public int numberOfArithmeticSlices(int[] A) {
        if(A==null || A.length<3){
            return 0;
        }
        
        int n = A.length;
        int[] dp = new int[n];
        int res = 0;
        for(int i=2; i<n; i++){
            if(A[i] - A[i-1] == A[i-1] - A[i-2]){
                dp[i] = dp[i-1] + 1;
            }
            res += dp[i];
        }
        
        return res;
    }
}
```



#### 异或和为0的子数组

Q：给一个数组arr, 将其分为若干个不相容的子数组, 求最多能分多少个异或和为0的子数组
不相容子数组: 数组中每个元素最多只能在一个子数组中出现
异或运算: 满足交换律和结合律. 任意数和0异或等于其本身, 任意数和自己异或是0
A：用dp[i]表示以第i个元素为数组的结尾时, 该数组能被分为最多异或和为0子数组的数量. 则有以下递推式:

`dp[i] = Math.max(dp[i-1], dp[j] + 1) (其中数组0~i 和 0~j的累积异或和是相等的)`

考虑数组的第i个元素所在的子数组, 如果在最优解里该子数组异或和不为0, 那么最后一个元素就没有贡献, 此时`dp[i] = dp[i-1]`; 如果在最优解里, 最后一个元素所在的子数组异或和为0, 那么去掉最后一个异或和为0的子数组, 前面的数组最优解记为dp[j], 则此时有`dp[i] = dp[j] + 1`, 但是要求`0~i`和`0~j`范围内的异或和相等, 这样才有`j+1~i`范围的异或和为0(即最后一个子数组的异或和为0)

遍历数组, 记录遍历到该位置时的异或和, 并在map中查找该异或和最后一次出现的位置, 如果是第一次出现, 则表明没有dp[j]的存在, 则`dp[i] = dp[i-1]`, 但是注意, 如果该位置的异或和为0, 且是第一次出现, 则`dp[i] = Math.max(1, dp[i-1])`, 因为异或和为0即是一种分法. dp[n-1]即是最终的结果

```java
public static int getMostSubArrayXOrSum(int[] arr) {
    if(arr == null || arr.length == 0) {
        return 0;
    }

    int sum = 0; // 异或和,map会记录其最后出现的位置,不用数组记录每个元素的累积异或和
    int[] dp = new int[arr.length];
    HashMap<Integer, Integer> sumAppearedLast = new HashMap<Integer, Integer>();
    sumAppearedLast.put(0, -1); // 异或和为0第一次出现特别标记
    for(int i = 0; i < arr.length; i++) {
        sum ^= arr[i];
        
        if(sumAppearedLast.containsKey(sum)) {
            int prePos = sumAppearedLast.get(sum);
            dp[i] = prePos == -1 ? 1 : dp[prePos] + 1;
        }
        sumAppearedLast.put(sum, i); // 异或和的位置总是最靠右的
        if(i > 0) {
            dp[i] = Math.max(dp[i], dp[i-1]); // 根据dp,它每一步有两种选择,选最大值
        }
    }

    return dp[arr.length-1];
}
```



### 分割整数

[回到总目录](#目录)

* [分割整数的最大乘积](#分割整数的最大乘积)
* [按平方数分割整数](#按平方数分割整数)

#### 分割整数的最大乘积

[343. Integer Break(Medium)](https://leetcode.com/problems/integer-break/description/)

Q: 给一个正整数n, 将其分割成若干个正整数的和, 求分割后若干个正整数的最大乘积. 如10 = 3+3+4, 最大乘积36

A: 假设dp[i]表示i被分割成若干个正整数后的最大乘积, 有以下递推式:

`dp[i] = Math.max(j*dp[i-j], j*(i-j)) (当i>j)`

对于每个i, j可以选`1~i-1`, 在这些dp中选取一个最大值, 即是要求值. 注意每个`j*dp[i-j]`都要和`j*(i-j)`比较取较大, 因为可能最大乘积就是分成i = j + (i-j), 而dp[i-j]不可能取到i-j的值, 所以这种情况要列出. 最终结果就是dp[n]

````java
class Solution {
    public int integerBreak(int n) {
        if(n < 3){
            return 1;
        }
        
        int[] dp = new int[n+1];                
        for(int i=2; i<=n; i++){
            for(int j=1; j<i; j++){
                dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)));
            }
        }
        
        return dp[n];
    }
}
````



#### 按平方数分割整数

[279. Perfect Squares(Medium)](https://leetcode.com/problems/perfect-squares/description/)

Q: 将整数n分成若干个平方数的和, 求最小的分割数量. 如 13 = 4 + 9, 则最小分割数量为2

A: 用dp[i]表示i能被分成若干个平方数和的最小分割数量, 则有以下递推式:

`dp[i] = Math.min(dp[i], dp[i-j]+1) (j是不大于i的平方数)`

遍历所有不大于i的平方数j, 得到最小的dp即是dp[i]的取值 

```java
class Solution {
    public int numSquares(int n) {
        if(n <= 0){
            return 0;
        }
        
        int[] dp = new int[n+1];
        List<Integer> squares = getSquares(n);
        for(int i=1; i<=n; i++){
            dp[i] = Integer.MAX_VALUE;
            for(Integer each:squares){
                if(each > i){
                    break;
                } else {
                    dp[i] = Math.min(dp[i], dp[i-each]+1);
                }
            }
        }
        
        return dp[n];
    }
    
    private List<Integer> getSquares(int n){
        List<Integer> squares = new ArrayList<>();
        int base = 1;
        int diff = 3;
        
        squares.add(base);
        while(base+diff <= n){
            squares.add(base+diff);
            base += diff;
            diff += 2;
        }
        
        return squares;
    }
}
```

S: 注意到这里的getSquares方法用来求不大于n的所有平方数列表, 它并没有用乘法, 而是用了加法, 因为一组连续平方数的差构成的数列, 是一个公差为2的等差数列, 利用这一点将平方运算都变成了加法运算, 节约了时间.



### 数组的子序列

数组的子数组或区间要求它们在原数组中也是连续的, 而子序列只要求它们在原数组的相对前后顺序是一样的即可, 不要求连续.

[动态规划总目录](#目录)

* [最长递增子序列](#最长递增子序列)
* [最长摆动子序列](#最长摆动子序列)
* [最长公共子序列](#最长公共子序列)
* [最大子序列乘积](#最大子序列乘积)

#### 最长递增子序列

[300. Longest Increasing Subsequence(Medium)](https://leetcode.com/problems/longest-increasing-subsequence/description/)

Q: 给定一个数组nums, 求其最长的递增子序列

A: 假设dp[i]表示以第i个元素结尾的最长递增子序列的长度, 则有以下递推式:

`dp[i] = Math.max(1, dp[j] + 1) (当j<i, 且nums[j]<nums[i])`

因为对于i前面所有结尾元素的最长递增子序列, 只要nums[i]大于它们, nums[i]就可以在子序列尾部结上, 即长度+1. 最终的最长递增子序列不一定是dp[n-1], 而是所有的dp中的最大值

````java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums==null || nums.length==0){
            return 0;
        }
        
        int n = nums.length;
        int[] dp = new int[n];
        for(int i=0; i<n; i++){
            dp[i] = 1;
            for(int j=0; j<i; j++){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[i], dp[j]+1);
                }
            }
        }
        
        int res = 1;
        for(Integer each:dp){
            res = Math.max(each, res);
        }
        
        return res;
    }
}
````



#### 最长摆动子序列

[376. Wiggle Subsequence(Medium)](https://leetcode.com/problems/wiggle-subsequence/description/)

Q: 给一个数组nums, 求它的最长摆动子序列长度. 最长摆动子序列中没有连续的三个元素组成单调区间.

```
Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].
```

A: 用up和down分别表示上一个最长摆动子序列最后为增时的长度 和 为减时的长度, 那么遍历到当前元素, 如果当前元素相比前一个元素为增, 那么up = down + 1, 反之, down = up + 1.

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if(nums==null || nums.length==0){
            return 0;
        }
        
        int up = 1;
        int down = 1;
        for(int i=1; i<nums.length; i++){
            if(nums[i] > nums[i-1]){
                up = down + 1;
            }
            if(nums[i] < nums[i-1]){
                down = up + 1;
            }
        }
        
        return Math.max(up, down);
    }
}
```



#### 最长公共子序列

Q: 给两个数组num1和num2, 求它们的最长公共子序列

A: 假设`dp[i][j]`表示num1第i个以前的元素 和 num2第j个以前的元素构成的最长公共子序列.  则它们有以下递推关系式:

````
dp[i][j] = dp[i-1][j-1] + 1 (当num1[i] == num2[j])
dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) (当 num1[i] != num2[j])
````

因为当`num1[i] == num2[j]`时, 两者的最后一个元素都为最长公共子序列做了一个贡献, 反之, 则两者的最后一个元素至少有一个元素没有对最长公共子序列做贡献

```java
public int lengthOfLCS(int[] nums1, int[] nums2) {
    int n1 = nums1.length, n2 = nums2.length;
    int[][] dp = new int[n1 + 1][n2 + 1]; 
    for (int i = 1; i <= n1; i++) {
        for (int j = 1; j <= n2; j++) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[n1][n2];
}

```



#### 最大子序列乘积

[152. Maximum product subarray(Medium)](https://leetcode.com/problems/maximum-product-subarray/)

Q：给一个int数组arr，包括正数，负数和0，求这个数组的最大子序列乘积

A：假设dp[i]表示包含arr[i]的子序列的最大乘积，用min[i]表示arr[i]子序列的最小乘积，那么dp[i]只可能在dp[i-1]xarr[i]，min[i-1]xarr[i]和arr[i]中取，同样min[i]，也只能在这三者之中取。这个递推关系的含义是：包含当前子序列的最大乘积只有三种情况，一种是本身，第二种是包含前一个元素的最大乘积x本身，第三种是包含前一个元素的最小乘积x本身。这是由于本身可能是负数或0导致的。
同时注意，dp[i]求出来的最大乘积并不一定是dp[n-1]，而是所有dp中的最大值。并且dp[i]的值并不一定是从第一个元素开始累乘的。

```java
class Solution {
    public int maxProduct(int[] nums) {
        if(nums==null || nums.length==0){
            return 0;
        }

        int[] dp = new int[nums.length];
        int[] min = new int[nums.length];
        dp[0] = nums[0];
        min[0] = nums[0];

        int res = nums[0];
        int i = 1;
        while(i < nums.length){
            dp[i] = Math.max(nums[i], Math.max(nums[i]*dp[i-1], nums[i]*min[i-1]));
            min[i] = Math.min(nums[i], Math.min(nums[i]*dp[i-1], nums[i]*min[i-1]));
            res = Math.max(res, dp[i]);
            i++;
        }

        return res;
    }
}
```



### 字符串编辑

[动态规划总目录](#目录)

* [删除两个字符串的字符使它们相等](#删除两个字符串的字符使它们相等)
* [编辑字符串使它们相等](#编辑字符串使它们相等)



#### 删除两个字符串的字符使它们相等

[583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/description/)

Q: 给两个字符串word1和word2, 删除这两个字符串中的某些字符, 使这两个字符串相等. 求最少删除的字符个数

```
Input: "sea", "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
```

A: 本质就是求两个字符串的[最长公共子序列](#最长公共子序列), 然后用两个字符串总字符数减去2倍的最长公共子序列长度即可

````java
class Solution {
    public int minDistance(String word1, String word2) {
        if(word1.length()==0 || word2.length()==0){
            return word1.length()==0 ? word2.length() : word1.length();
        }
        
        int n1 = word1.length();
        int n2 = word2.length();
        int[][] dp = new int[n1+1][n2+1];
        
        for(int i=1; i<=n1; i++){
            for(int j=1; j<=n2; j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]);
                }
            }
        }
        
        return n1 + n2 - 2*dp[n1][n2];
     }
}
````



#### 编辑字符串使它们相等

[72. Edit Distance](https://leetcode.com/problems/edit-distance/description/)

Q: 给两个字符串word1和word2, 编辑word1, 使其等于word2, 求最少编辑次数. 允许的编辑有插入/删除/替换, 每种编辑都增加一次编辑次数

```
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

A: 用`dp[i][j]`表示使word1前i个字符串等于word2前j个字符串的最少编辑次数. 则有以下递推关系式:

```
dp[i][j] = dp[i-1][j-1] (当word1[i-1] == word2[j-1])
dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 (当word1[i-1] != word2[j-1])
```

因为当`word1[i-1] == word2[j-1]`时, 相当于word1的第i个字符和word2的第j个字符不用编辑; 而当它们不等时, 编辑的方式有三种:插入/删除/替换. 插入后,可以不再关注word2第j个字符, 即`dp[i][j-1]`, 删除后, 可以不再关注word1的第i个字符, 即`dp[i-1][j]` 替换后, word1的第i个字符和word2的第j个字符都不用关注, 即`dp[i-1][j-1]`. 取最小的编辑方式即为最优.

注意, 插入/删除/替换都是在编辑word1.

````java
class Solution {
    public int minDistance(String word1, String word2) {
        if(word1.length()==0 || word2.length()==0){
            return word1.length()==0 ? word2.length() : word1.length();
        }
        
        int n1 = word1.length();
        int n2 = word2.length();
        int[][] dp = new int[n1+1][n2+1];
        
        for(int i=1; i<=n2; i++){ // basecase,需要用到
            dp[0][i] = i;
        }
        for(int i=1; i<=n1; i++){
            dp[i][0] = i;
        }
        
        for(int i=1; i<=n1; i++){
            for(int j=1; j<=n2; j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;
                }
            }
        }
        
        return dp[n1][n2];
    }
}
````

S: 注意这里有basecase, 是因为后面的递推关系式会用到. 即在递推时, 有这样的basecase实际发生.





### 其它

[动态规划总目录](#目录)

* [n个骰子所有和的次数统计](#n个骰子所有和的次数统计)
* [鸡蛋掉落判断碎蛋层高](#鸡蛋掉落判断碎蛋层高)
* [三角形二叉树的最小路径](#三角形二叉树的最小路径)

#### n个骰子所有和的次数统计

Q: 投n个骰子,每个骰子的点数为1~6,求它们和的所有可能性,以及每种可能发生的次数

A: 用`dp[i][j]`表示投i个骰子, 点数为j时的可能发生次数, 易知`i<=j<=6*i`, 且有以下递推式:

`dp[i][j] = sum{dp[i-1][j-k]} (k:1~6 但是要求i-1 <= j-k <= 6(i-1))`

即考虑最后一个骰子为k点, 则前面i-1个骰子的为j-k点时的所有可能结果, 都是满足`dp[i][j]`的.

```java
public static int[] getSumTimes(int n){
    if(n <= 0){
        return null;
    }

    int[][] dp = new int[n+1][6*n+1]; // 骰子点数范围:n~6n,数组大点是为了保持索引和骰子数一致
    
    for(int i=1; i<=6*n; i++){ // base-case
        dp[1][i] = 1;
    }
    
    for(int i=2; i<=n; i++){
        for(int j=i; j<=6*i; j++){
            for(int k=1; k<=6; k++){
                if(j-k < i-1 || j-k > 6*(i-1)){
                    break;
                }
                dp[i][j] += dp[i-1][j-k];
            }
        }
    }
    
    int[] res = new int[5*n+1]; // 整理结果
    for(int i=n; i<=6*n; i++){
        res[i-n] = dp[n][i];
    }
    return res;
}
```

**优化空间复杂度**

从递推关系式可以知道,每个dp值只与它的上一维度dp值有关,而上面的dp求出了所有的维度.所以是O(N^2)
可以通过旋转二维数组,将其降低到O(N),即只用一个2*n的二维数组.其中一行存现在的数,另一行存上次的数,记得每次存现在的数时得清除上上次的数,不然可能会影响正确结果值

````java
public static int[] getSumTimes(int n){
    if(n <= 0){
        return null;
    }

    int[][] dp = new int[2][6*n+1]; // 骰子点数范围:n~6n,数组大点是为了保持索引和骰子数一致
    
    for(int i=1; i<=6*n; i++){ // base-case
        dp[0][i] = 1;
    }
    
    int flag = 0; 
    for(int i=2; i<=n; i++){
        flag =  1 - flag; // "上上次"使用的可以覆盖
        for(int j=i; j<=6*i; j++){
            dp[flag][j] = 0; // 清零,避免"上上次"残留影响累加
            for(int k=1; k<=6; k++){
                if(j-k < i-1 || j-k > 6*(i-1)){
                    break;
                }
                dp[flag][j] += dp[1-flag][j-k]; // flag 和 1-flag表示现在和上一次
            }
        }
    }
    
    int[] res = new int[5*n+1]; // 整理结果
    for(int i=n; i<=6*n; i++){
        res[i-n] = dp[flag][i];
    }
    return res;
}
````

S: 这里是使用旋转数组来优化空间复杂度, 用了两个一维数组, 其实用一个一维数组可以进一步减少空间的使用.即消除i这个维度, 每次求`dp[i][j]`时按j从大往小求, 因为`dp[i][j]`依赖的`dp[i-1][j-k]`, 所以从大往小求时, 一维的dp[j-k]其实是还没有更新的(相当于`dp[i-1][j-k]`), 而目前更新的dp[j]就覆盖了上一个dp[j], 相当于`dp[i][j]`



#### 鸡蛋掉落判断碎蛋层高

Q: 有一栋N层高的建筑, 存在楼层 F , 满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会碎。无论F值为多少, 给定k个鸡蛋, 判断N层高建筑的碎蛋层高F的最少扔蛋次数是多少?

A: 假设dp[i,j]表示有i个蛋, 对于j层高建筑F值判断的最小扔蛋次数, 则有以下递推式:

`dp[i][j] = min(max(dp[i-1][k-1], dp[i][j-k]) + 1) (其中k < j)`

在第i层扔蛋, 如果蛋碎, 那么蛋的数量变成k-1, 并且需要判断的楼层高度变为i-1, 即还需`dp[k-1][i-1]`次扔蛋; 但是如果蛋没碎, 那么蛋的数量仍然是k, 需要判断的层高变为n-i, 即还需`dp[k][n-i]`次扔蛋. 这两种情况都有可能发生, 取决于F的取值, 而F是可以任意取值的, 所以这两种情况要取较大值才能应对所有F取值. 而第一次在哪一层扔蛋, 这个是可以自己选择的, 所以在所有`i<n`的dp结果取值里, 要取最小值, 才是最优解.

````java
public static int getSteps(int k, int n){
    if((1<<k) > n){ // 如果鸡蛋足够多,直接二分
        int res = 0;
        while(n != 0){
            n = n >> 1;
            res++;
        }
        return res;
    }
    
    int[][] dp = new int[k+1][n+1];
    for(int i=1; i<=n; i++){ // 只有1个鸡蛋
        dp[1][i] = i;
    }
    for(int i=1; i<=k; i++){ // 只有1层
        dp[i][1] = 1;
    }
    if(k==1 || n==1){
        return k==1 ? n : 1;
    }
    
    for(int i=2; i<=k; i++){
        for(int j=2; j<=n; j++){
            for(int k=1; k<j; k++){
                dp[i][j] = Math.min(dp[i][j], Math.max(dp[i-1][k-1], dp[i][j-k])) +1;
            }
        }
    }
}
````



#### 三角形二叉树的最小路径

[120. Triangle](https://leetcode.com/problems/triangle/)

Q：给一个二维数组arr，可以认为其是一个满二叉树构成的数组(无对应节点的位置值为0)，求从“满二叉树”的头节点遍历到叶节点的所有路径中，路径经过节点的最小和值。如图，6和5就是3能走的两个路径，5和7是4能做走的两个路径。

![1557023151013](../img/三角形的最小路径.png)

A：由题意，很容易想到递推式：dp(i, j) = min(dp(i+1, j), dp(i+1, j+1) + arr(i, j)  即从当前节点往下走的路径最小值取决于它走左边和走右边两种情况的较小值+当前节点的值。如果从上往下看这个递推式，它就是一个递归；从下往上看，它就是一个递推。最后一行的所有dp值都为其本身，然后从倒数第二行开始往上层求，最终的答案是dp(0,0)

````java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        if(triangle==null || triangle.size()==0 || triangle.get(0)==null || triangle.get(0).size()==0){
            return 0;
        }
        
        int row = triangle.size();
        List<Integer> tempLast = triangle.get(row-1);
        int col = tempLast.size();
        int[][] dp = new int[row][col];
        
        int i = 0;
        for(Integer each:tempLast){
            dp[row-1][i++] = each;
        }
        
        i = row-2;
        while(i >= 0){
            List<Integer> tempList = triangle.get(i);
            for(int j=0; j<(i+1); j++){
                dp[i][j] = Math.min(dp[i+1][j], dp[i+1][j+1]) + tempList.get(j);
            }
            i--;
        }

        return dp[0][0];
    }
}
````



### 股票交易系列问题

[动态规划总目录](#目录)

[股票交易系列问题](../经典题型/买卖股票系列问题.md)



### 背包问题

[动态规划总目录](#目录)

[背包问题](../经典题型/背包问题.md)