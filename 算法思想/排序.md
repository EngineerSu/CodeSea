## 排序算法

### 目录

**排序算法:**

* [选择排序](#选择排序)
* [冒泡排序](#冒泡排序)
* [插入排序](#插入排序)
* [归并排序](#归并排序)
* [随机快排](#随机快排)
* [堆排序](#堆排序)
* [桶排序](#桶排序)
* [排序总结](#排序总结)

**排序题型:**

* [merge: 小和问题](#小和问题)
* [partition: 荷兰国旗问题](#荷兰国旗问题)
* [数组排序后最大相邻差](#数组排序后最大相邻差)



----

### 选择排序

[回到目录](#目录)

时间复杂度:O(N^2^)	不稳定

```java
public static void chooseSort(int[] arr){
    if(arr == null || arr.length < 2){
        return;
    }
    
    for(int i = 0; i < arr.length; i++){
        for(int j = i+1; j < arr.length; j++){
            if(arr[i] > arr[j]){
                swap(arr, i, j);
            }
        }
    }
}
```

### 冒泡排序

[回到目录](#目录)

时间复杂度:O(N^2^)	稳定

```java
public static void bubbleSort(int[] arr){
    if(arr == null || arr.length < 2){
        return;
    }
    
    for(int i = arr.length-1; i > 0; i--){
        for(int j = 0; j+1 <= i; j++){
            if(arr[j+1] < arr[j]){
                swap(arr, j ,j+1);
            }
        }
    }
}
```

### 插入排序

[回到目录](#目录)

时间复杂度:O(N^2^)	稳定

插排在工程上还有使用,因为它的常数项很小,常用于小数据量的排序. 虽然它的时间复杂度和选择/冒泡一样,但是选择/冒泡固定是O(N^2^),而插排是最坏情况O(N^2^).

```java
public static void bubbleSort(int[] arr){
    if(arr == null || arr.length < 2){
        return;
    }
    
    for(int i = 0; i < arr.length; i++){
        for(int j = i; j-1 >= 0; j--){
            if(arr[j] < arr[j-1]){
                swap(arr, j-1 ,j);
            } else {
                break;
            }
        }
    }
}
```

### 归并排序

[回到目录](#目录)

时间复杂度:O(N*logN)	稳定

```java
public static void mergeSort(int[] arr, int p1, int p2){

    if(arr == null || arr.length == 0 || p1 >= p2){
        return;
    }

    int mid = (p1+p2) >> 1;
    mergeSort(arr, p1, mid);
    mergeSort(arr, mid+1, p2);
    merge(arr, p1, mid, p2);
}

private static void merge(int[] arr, int p1, int mid, int p2) {

    int s1 = p1;
    int s2 = mid+1;
    int[] temp = new int[p2-p1+1];
    int index = 0;
    while(s1 <= mid && s2 <= p2){
        temp[index++] = arr[s1] < arr[s2] ? arr[s1++] : arr[s2++];
    }

    while(s1 <= mid){
        temp[index++] = arr[s1++];
    }
    while(s2 <= p2){
        temp[index++] = arr[s2++];
    }

    index = 0;
    while(index < temp.length){
        arr[p1++] = temp[index++];
    }
}
```

### 随机快排

[回到目录](#目录)

时间复杂度:O(N*logN)	不稳定

```java
public static void quickSort(int[] arr, int l, int r){
    if(arr == null || arr.length == 0 || l >= r){
        return;
    }
    
    int rand = l + (int)(Math.random()*(r-l+1));
    int[] equalIndex = partition(arr, l, r, arr[rand]);
    quickSort(arr, l, equalIndex[0]-1);
    quickSort(arr, equalIndex[1]+1, r);
}

public static int[] partition(int[] arr, int l, int r, int num){
    if(arr == null || arr.length == 0 || l >= r){
        return;
    }
    
    int small = l - 1;
    int equal = l;
    int big = r + 1;
    
    while(equal < big){
        if(arr[equal] < num){
            swap(arr, ++small, equal++);
        } else if(arr[equal] == num){
            equal++;
        } else {
            swap(arr, --big, equal);
        }
    }
    
    return new int[]{small+1, big-1};
}
```

### 堆排序

[回到目录](#目录)

时间复杂度:O(N*logN)	不稳定

```java
public static void heapSort(int[] arr){
    if(arr == null || arr.length <= 1){
        return;
    }

    createHeap(arr); // 将数组变成大根堆

    int heapPos = arr.length - 1; // 大根堆的位置就到了数组中最后一个元素
    while(heapPos > 0){ // 每次交换堆顶和堆中最后一个元素,直到堆顶就是堆中最后一个元素
        ArrayUtils.swap(arr, 0, heapPos--);
        heapify(arr, 0, heapPos);
    }
}

public static void createHeap(int[] arr){

    int heapSize = 0;
    while(heapSize < arr.length-1){
        int cur = ++heapSize;
        int dad = (cur-1) >> 1;
        while(dad >= 0 && arr[cur] > arr[dad]){
            ArrayUtils.swap(arr, cur, dad);
            cur = dad;
            dad = (cur-1) >> 1;
        }
    }

}

private static void heapify(int[] arr, int i, int heapPos) {

    int leftChild = (i<<1) + 1;
    int rightChild = leftChild + 1;
    int maxChild;

    while(leftChild <= heapPos){

        if(rightChild <= heapPos &&  Math.max(arr[leftChild], arr[rightChild]) == arr[rightChild]){
            maxChild = rightChild;
        } else {
            maxChild = leftChild;
        }
        if(arr[i] >= arr[maxChild]){
            break;
        } else {
            ArrayUtils.swap(arr, i, maxChild);
            i = maxChild;
            leftChild = (i<<1) + 1;
            rightChild = leftChild + 1;
        }
    }

}
```

### 桶排序

[回到目录](#目录)

时间复杂度:O(N)	桶排序是非基于比较的排序,它有一定的适用范围.

假设一个整数组的所有元素范围是0~60,则建立一个额外长度为61(相当于61个桶)的数组,遍历原数组,数组中每一个元素必定落在这61个桶之中,遍历完后,额外数组相当于记录了原数据中各个元素出现的次数,遍历额外数组,将其按顺序打印出即可.



### 排序总结

[回到目录](#目录)

工程排序针对自定义对象使用归并排序(稳定性),对于数值使用快排. 对于小数据量使用插排,因为插排时间复杂度的常数项小.



## 排序题型

### 小和问题

[回到目录](#目录)

Q:对于一个数组,所有元素左侧比它小的元素的和称为小和.

A:在merge外排的过程中求小和(目的不是为了排序,只是在排序之前顺带把小和求了)

```java
public static int getSmallSum(int[] arr){
    if(arr == null || arr.length < 2){
        return 0;
    }
    
    return process(arr, 0, arr.length-1);
}

public static int process(int[] arr, int left, int right){
    if(arr == null || arr.length < 2 || right - left < 1){
        return 0;
    }
    
    int mid = (left+right) > 1;
    int sum = process(arr, left, mid) + process(arr, mid+1, right);
    return sum + merge(arr, left, mid, right);
}

public static int merge(int[] arr, int left, int mid, int right){    
    int p1 = left;
    int p2 = mid + 1;
    int sum = 0;
    int[] temp = new int[right-left+1];
    int index = 0;
    
    while(p1 <= mid && p2 <= right){
        if(arr[p1] < arr[p2]){
            sum += arr[p1] * (right-p2+1);
            temp[index++] = arr[p1++];
        } else {
            temp[index++] = arr[p2++];
        }    
    }
    
    while(p1 <= mid){
        temp[index++] = arr[p1++];
    }
    while(p2 <= right){
        temp[index++] = arr[p2++];
    }
    index = 0;
    while(index < temp.length){
        arr[left++] = temp[index++];
    }
    
    return sum;
}
```

**子问题1:求数组逆序对**

Q:对于数组中的元素,在数组左边所有比它小的元素和它构成一组逆序对,求数组所有的逆序对

A:和小和问题一样,也是在归并排序的merge过程中求出逆序对



### 荷兰国旗问题

[回到目录](#目录)

Q:给一个数组arr和一个整数num,将所有小于num的数放在左边,等于num的数放中间,大于num的数放右边

A:partition过程,用small和big指针分别表示小于区和大于区的边界(初始为-1和n-1),equal指针遍历数组,如果小于num,就和++small交换,等于直接equal++,大于num则和--big交换.

```java
public static int[] partition(int[] arr, int num){
    if(arr == null || arr.length == 0){
        return;
    }
    
    int small = -1;
    int big = arr.length();
    int equal = 0;
    
    while(equal < big){
        if(arr[equal] < num){
            swap(arr, ++small, equal++);
        } else if(arr[equal] == num){
            equal++;
        } else {
            swap(arr, equal, --big);
        }
    }
    
    return new int[]{small+1, big-1}; // 返回equal区(闭区间)的两个边界
}
```



### 数组排序后最大相邻差

[回到目录](#目录)

Q:给定一个数组,求数组排序后最大的相邻差.时间复杂度要求:O(N)

A:分桶思想,根据数组的最值max,min和数组长度N,分成(N+1)个桶,至少有一个空桶.所以最大相邻差肯定不在一个桶内,遍历所有桶的最值,用当前非空桶的最小值-上一个非空桶的最大值,所有这些结果的最大值即是结果

```java
public static int getMaxNeighbouringDiff(int[] arr){
    if(arr == null || arr.length < 2){
        return 0;
    }
    
    int min = arr[0];
    int max = arr[0];
    boolean[] hasEle = new boolean[arr.length+1];
    int[] minBucket = new int[arr.length+1];
    int[] maxBucket = new int[arr.length+1];
    
    int index = 0;
    while(index < arr.length){
        min = Math.min(min, arr[index]);
        max = Math.max(max, arr[index]);
        index++;
    }
    index = 0;
    while(index < arr.length){
        int shot = (arr[index]-min)/max * arr.length;
        hasEle[shot] = true;
        minBucket[shot] = Math.min(minBucket[shot], arr[shot]);
        maxBucket[shot] = Math.max(maxBucket[shot], arr[shot]);
    }
    
    int last = -1;
    int cur = -1;
    int res = 0;
    index = 0;
    while(index < hasEle.length){
        if(hasEle[index]){
            last = cur;
            cur = index;
            res = last != -1 ? Math.max(res, minBucket[cur] - maxBucket[last]) : 0;
        }
        index++;
    }
}
```

