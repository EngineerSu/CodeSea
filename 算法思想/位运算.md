## 位运算

有时运用位运算可以巧妙地解决一些问题, 位运算的时间复杂度往往很小.

---

### 常见位运算

```
n = n & (n-1)  =>  消除n最右侧的1(如10110, 得到10100)
a = n & -n  =>  得到n最低位的1(如10100，得到00100)
```

### 目录

* [二进制数包含1的个数](#二进制数包含1的个数)
* [数组中两个只出现一次的数](#数组中两个只出现一次的数)
* [不用加减乘除做加法](#不用加减乘除做加法)
* [N皇后问题](#N皇后问题)



-----

### 二进制数包含1的个数

[位运算目录](#目录)

Q: 给一个整数num, 试判断num的二进制形式有多少个1.

```
Input: 3
Output: 2

3 的二进制是 11 , 因此包含两个1
```

A: 使用`n = n & (n-1)`位运算, 可以消除n二进制位中最右侧的1, 直到n为0的运算次数即是1的个数

```java
public static getOnes(int num){
    int cnt = 0;
    while(num != 0){
        num &= num - 1;
        cnt++;
    }
    return cnt;
}
```

**子问题**

1. 快速判断n是否为2的整数次方: 等价于判断n的二进制位是否只有一个1
2. 快速判断m和n的二进制位有多少位是不同的: 等价于判断m^n的二进制位有多少个1



### 数组中两个只出现一次的数

[位运算目录](#目录)

Q: 数组num中有两个数只出现一次, 其他数都出现两次, 求这两个数. 如[11,22,22,33,44,44]中11和33只出现一次

A: 首先将整个数组做异或运算, 结果就是两个只出现一次的数的异或结果, 判断这个结果二进制位中第一个1出现的位置, 这个位置就是这两个数二进制位中第一个不相同的位, 必有一个是1, 一个是0. 根据这一点, 将每个数做一个位运算, 根据它们在这个位置是1或是0分成两组, 出现两次的数比分在同一组, 这两个出现一次的数必分在不同的组. 分别对两组做异或运算, 两个异或运算的结果即是这两个数.

````java
public static int[] findNums(int[] nums){
    if(nums==null || nums.length<2){
        return null;
    }
    
    int xor = 0;
    for(Integer num:nums){
        xor ^= num;
    }
    int pos = 0;
    xor &= -xor; // 得到xor最低位的1 
    while((1<<pos) & xor != xor){ // 找到xor最右侧的1在第几位,第一位pos对应0
        pos++;
    }
    
    int[] res = new int[2];
    for(Integer num:nums){
        if(num & (1<<pos) == 0){
            res[0] ^= num;
        } else {
            res[1] ^= num;
        }
    }    
    return res;
}
````



### 不用加减乘除做加法

[位运算目录](#目录)

Q: 给两个数字a,b.不用加减乘除得出a+b的结果

A:  数字运算除了四则运算就剩下位运算.用位运算模拟加法的过程

```
模拟两个数不管进位的加法: sum = a^b;
获取两个数相加的进位: carry = (a&b) << 1;
将sum和carry相加(重复1和2的步骤,直至没有进位)
```

```java
public static int imitatePlusByBinary(int a, int b){
    int sum = a ^ b;
    int carry = (a&b) << 1;
    while(carry != 0){
        int temp = sum;
        sum = sum^carry;
        carry = (temp&carry) << 1;
    }
    return sum;
}
```



### N皇后问题

[位运算目录](#目录)

Q：在N*N的棋盘（矩阵，二维数组）中，要存放N个皇后，使她们互不攻击，即不能同一行，不能同一列，也不能在一条对角线上。求有多少种摆放皇后的方法

A：每一行只能摆放一个皇后，用深度遍历，遍历到每一行时，求这一行还能有哪些列能摆放皇后，如果没有能摆放皇后的位置，则说明前面行摆放皇后的位置不满足条件，提前返回；若遍历完了所有行，表明完成了一次有效的摆放，则摆放次数+1。关键点：如何判断这一行还有哪些列能摆放皇后？

方法1：用遍历的方法，针对每列摆放皇后进行查看它的每行每列两条对角线，观察是否冲突。

方法2：col，pie，na是三个int整数，用三个整数二进制位的0~N位表示当前行的列是否可以放置皇后，为0的时候表示这个列可以放置皇后，为1的时候表示这个列不可以放置皇后。假设N=10，当前行的第5列放置了皇后，那么col的第五位就要置1，pie表示当前行第5列那个格点左下角的对角线列，所以pie第五位也先置1，再左移一位，因为pie表示的由于前面已放置皇后带来的，左对角线不能存放皇后的列的位置，而左对角线每下移一行，也要左移一列；同理na也是第五位先置1，再右移一位。

S：注意逻辑运算和位运算不要混淆；对常见位运算的作用要熟悉；位运算优先级很低，注意带括号

````java
public static int getNQueen(int n){
    if(n <= 0){
        return 0;
    }

    return process(0, 0, 0, 0, n);
}

private static int process(int row, int col, int pie, int na, int n){
    if(row == n){
        return 1;
    }
    int cnt = 0;
    // col|pie|na中的0位表示还可以存放皇后的列，取反得到1位变成了可以存放皇后的列
    // 取反的时候，32位int前面一些0位变成了1，1<<N - 1作用是只取0~N位，其他位舍去
    int p = (~(col|pie|na)) & ((1<<n) - 1);
    while(p > 0){
        int cur = p & -p; // 得到cur最右边一位的1表示的二进制位
        // 将col，pie，na相关位置1，继续往下走
        cnt += process(row+1, col|cur, (pie|cur)<<1, (na|cur)>>1, n);
        p &= p-1; // 除去cur最右边一位1
    }

    return cnt;
}
````

