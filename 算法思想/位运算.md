## 位运算

### 整数二进制有多少1 &

Q: 如3的二进制是11,有两个1

```
A1:如果不考虑负数,每次将这个数与1做&运算,就能知道这个数最右边是不是1.然后将这个数右移一位,直到为0
A2:负数右移时左边会填充1,所以可以每次将1左移1位.
A3:最优解.利用n = n&(n-1)去掉了n中最右侧的一个1.看这个运算能做多少次即可
A3的解法保证了n中有几个1,就执行多少步,时间复杂度最优
```

```
运用n = n&(n-1)还能做很多类似的题目
比如Q2:判断一个数是不是2的整数次方(二进制只有一个1)
	比较两个数m和n的二进制有多少位是不同的(统计m^n的二进制1的个数)
```

### 数组中只出现一次的数 ^

Q:数组中有两个数只出现一次,其他数都出现两次,求这两个数.如{11,22,22,33,44,44}中11和33只出现一次

```
如果求数组中一个只出现一次的数,可以将数组中所有数做异或,因为两个相同的数异或结果为0,0和任意数异或为本身,所以异或结果就是这个不同的数.
求两个不同的数,关键在于将这个数组分成两组,如果每组中只包含一个不同的数,那么就相当于把问题转换了.既然要把这两个数分到不同的组里,就要用他们不同的标准.它们肯定是不同的数,所以它们的二进制数从某一位开始一定是不同的,分析整个数组异或结果,找到第一个二进制位为1即为这两个数的不同位.根据二进制的不同位,将数组分为两组,再分别做异或运算,得出来的结果就是这两个数.
```

```
判断两个不同的数异或结果的二进制中,第一个1出现的位置.假如num的第一个1出现在第n位,那么
	num & (1<<(n-1)) == 1; 而不是  num & (1<<n) == 1;
```

### 不用加减乘除做加法

Q:给两个数字a,b.不用加减乘除得出a+b的结果

```
数字运算除了四则运算就剩下位运算.用位运算模拟加法的过程:
1.模拟两个数不管进位的加法: sum = a^b;
2.获取两个数相加的进位: carry = (a&b) << 1;
3.将sum和carry相加(重复1和2的步骤,直至没有进位)
```

```java
public static int imitatePlusByBinary(int a, int b){
    
    int sum = a ^ b;
    int carry = (a&b) << 1;
    while(carry != 0){
        int temp = sum;
        sum = sum^carry;
        carry = (temp&carry) << 1;
    }
    
    return sum;
}
```

