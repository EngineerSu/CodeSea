## BFS与DFS

### 目录

[**BFS**](#BFS)

- [n次后A不小于B](#n次后A不小于B)
- [倒水游戏-三杯](#倒水游戏-三杯)



### BFS

广度优先遍历，二叉树的层遍历就是一种经典的BFS。相比于DFS可能有太深逸出的风险，BFS在解决某些问题时，是高效的。

比如，当问题是要求满足某个条件的树的最低层次时，用 BFS 可能会更优。因为如果用 DFS 求某个最低层，需要跑完所有路径，如果树中存在较深路径，显然用 DFS 代价就很大。而 BFS 由于是逐层扫描，扫描到满足条件层即可停止。

#### n次后A不小于B

[目录](#目录)

Q：给定2个整数A，B(A<B)和2个因子p，q。现在可以对A或p做一定变化，要么`A=A+p`，要么`p=p*q`，问至少变化多少次后，有A不小于B

A：自定义一个Node类，它包含a和p两个属性，它们的变化可以描述为：从头节点开始，每个节点都有两个孩子，左孩子的a比头节点的a多p，右孩子的p=头节点的p*q。因此问题就变成了从一棵树的头节点开始，寻找第一个满足a>=b的节点深度。

如果用回溯，就是一种DFS的思想。但是DFS存在深度溢出的风险，本题就是溢出的典型（当 q 仅比 1 大一点点时，p = p*q 这一条支路要分裂很长才能满足要求），因为一个节点的左右孩子若都找不到a>=b的节点，就得继续往更深处分裂，可能越分裂，越找不到，这样就是一个无限长的深度路径。

因此，需要使用BFS来做，相当于层遍历这颗树，第一个找到满足a>=b节点所在的层高即是答案。因为是从左往右的层遍历，不会有刚才深度溢出的风险。

```java
// 用于BFS的节点内部类
private static class Node {
    int a;
    int p;
    Node left;
    Node right;
}

public int process(int a, int b, int p, int q) {
    Node head = new Node(a, p);
    Queue<Node> queue = new LinkedList<Node>();
    queue.offer(head);
    int left = 1;
    // 记录正在遍历的层高，即找到满足条件节点需要变化的次数
    int layer = 0;
    while (!queue.isEmpty()) {
        Node cur = queue.poll();
        left--;
        if (cur.a >= b) {
            // 找到
            return layer;
        } else {
            // 没找到，分裂左右孩子，入列
            Node left = new Node(cur.a + p, p);
            Node right = new Node(cur.a, p * q);
            // 不用指定左右孩子关系，入列后面即会遍历到
            queue.offer(left);
            queue.offer(right);
        }
        if (left == 0) {
            // 表明当前层最后一个元素遍历完，队列中剩下的元素就是下一层
            left = queue.size();
            layer++;
        }
    }
    // 只要有答案，一定能够在while中return，否则没有答案return -1
    return -1;
}
```



#### 倒水游戏-三杯

[目录](#目录)

Q：给你一个装满水的 a 升满壶和两个分别是 b 升、c 升的空壶，现在需要得到 k 升水，每一步的操作只能是倒空或倒满。问至少需要多少步？

```
输入：8 5 3 4
输出：6
解释：1 4 3 <-- 1 5 2 <-- 6 0 2 <-- 6 2 0 <-- 3 2 3 <-- 3 5 0 <-- 8 0 0
```

A：定义一个Node，它有3个属性：a b c，表示目前三个水壶分别装了多少水，那么每次的状态生成最多可能有6种：从3个水壶中任取两个x，y，在满足条件的情况下，可以x往y中倒或y往x中倒，得到一个新的状态，并且需要用一个Set记录状态，避免新生成的状态和前面重复。

因此就是从8 0 0这个头节点开始存一个队列，只要队列不为空，每次从队列中取出一个节点，若节点三个属性中有一个4，则此节点的层数即是至少需要操作的步数。若不满足，则找出该节点操作一步的所有可能状态，这些状态中若未在set中出现则也入列。重新开始从队列中弹出一个节点检查，直到找到答案。