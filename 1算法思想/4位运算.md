## 位运算

### 目录

- [常见位运算](#常见位运算)
- [二进制数包含1的个数](#二进制数包含1的个数)
- [数组中两个只出现一次的数](#数组中两个只出现一次的数)
- [不用加减乘除做加法](#不用加减乘除做加法)
- [N皇后问题](#N皇后问题)



---

### 常见位运算

```
测试第 k 位: s & (1 << k)
设置第 k 位: s |= (1 << k)
第 k 位置零: s &= ~(1 << k)
切换第 k 位值: s ^= ~(1 << k)
乘以 2n: s << n
除以 2n: s >> n
交集: s & t
并集: s | t
减法: s & ~t
交换 x = x ^ y ^ (y = x)
取出最小非 0 位（Extract lowest set bit）: s & (-s)
取出最小 0 位（Extract lowest unset bit）: ~s & (s + 1)
交换值: x ^= y; y ^= x; x ^= y;
n = n & (n-1)  =>  消除n最右侧的1(如10110, 得到10100)
a = n & -n  =>  得到n最低位的1(如10100，得到00100)
```



### 二进制数包含1的个数

[目录](#目录)

Q: 给一个整数num, 试判断num的二进制形式有多少个1.

```
Input: 3
Output: 2

3 的二进制是 11 , 因此包含两个1
```

A: 使用`n = n & (n-1)`位运算, 可以消除n二进制位中最右侧的1, 直到n为0的运算次数即是1的个数

```java
public static getOnes(int num){
    int cnt = 0;
    while(num != 0){
        num &= num - 1;
        cnt++;
    }
    return cnt;
}
```

**子问题**

1. 快速判断n是否为2的整数次方: 等价于判断n的二进制位是否只有一个1
2. 快速判断m和n的二进制位有多少位是不同的: 等价于判断m^n的二进制位有多少个1



### 数组中两个只出现一次的数

[目录](#目录)

Q: 数组num中有两个数只出现一次, 其他数都出现两次, 求这两个数. 如[11,22,22,33,44,44]中11和33只出现一次

A: 首先将整个数组做异或运算, 结果就是两个只出现一次的数的异或结果, 判断这个结果二进制位中第一个1出现的位置, 这个位置就是这两个数二进制位中第一个不相同的位, 必有一个是1, 一个是0. 根据这一点, 将每个数做一个位运算, 根据它们在这个位置是1或是0分成两组, 出现两次的数比分在同一组, 这两个出现一次的数必分在不同的组. 分别对两组做异或运算, 两个异或运算的结果即是这两个数.

````java
public static int[] findNums(int[] nums){
    if(nums==null || nums.length<2){
        return null;
    }
    int xor = 0;
    for(Integer num:nums){
        xor ^= num;
    }
    // 取出最右侧的非0位
    xor = xor & (-xor);
    int[] res = new int[2];
    for(Integer num:nums){
        if(num & xor == 0){
            res[0] ^= num;
        } else {
            res[1] ^= num;
        }
    }    
    return res;
}
````



### 不用加减乘除做加法

[目录](#目录)

Q: 给两个数字a,b.不用加减乘除得出a+b的结果

A:  数字运算除了四则运算就剩下位运算.用位运算模拟加法的过程

```
模拟两个数不管进位的加法: sum = a^b;
获取两个数相加的进位: carry = (a&b) << 1;
将sum和carry相加(重复1和2的步骤,直至没有进位)
```

```java
public static int imitatePlusByBinary(int a, int b){
    int sum = a ^ b;
    int carry = (a & b) << 1;
    while(carry != 0){
        int temp = sum;
        sum = sum^carry;
        carry = (temp&carry) << 1;
    }
    return sum;
}
```



### N皇后问题

[目录](#目录)

Q：在N*N的棋盘（矩阵，二维数组）中，要存放N个皇后，使她们互不攻击，即不能同一行，不能同一列，也不能在一条对角线上。求有多少种摆放皇后的方法

A：每一行只能摆放一个皇后，用深度遍历，遍历到每一行时，求这一行还能有哪些列能摆放皇后，如果没有能摆放皇后的位置，则说明前面行摆放皇后的位置不满足条件，提前返回；若遍历完了所有行，表明完成了一次有效的摆放，则摆放次数+1。关键点：如何判断这一行还有哪些列能摆放皇后？

方法1：用遍历的方法，针对每列摆放皇后进行查看它的每行每列两条对角线，观察是否冲突。

方法2：col，pie，na是三个int整数，用三个整数二进制位的0~N位表示当前行的列是否可以放置皇后，为0的时候表示这个列可以放置皇后，为1的时候表示这个列不可以放置皇后。假设N=10，当前行的第5列放置了皇后，那么col的第五位就要置1，pie表示当前行第5列那个格点左下角的对角线列，所以pie第五位也先置1，再左移一位，因为pie表示的由于前面已放置皇后带来的，左对角线不能存放皇后的列的位置，而左对角线每下移一行，也要左移一列；同理na也是第五位先置1，再右移一位。

**pie 和 na在移动过程中会丢失信息吗(不同对角线边界不一样)?**

不会, 因为只取最低的n位, 所以左移超过部分会被去掉. 而右移超过部分会自动去掉

**对于上一行递归带来的col, pie, na, 如何表示这一行可以放皇后的列?** 

(~ (col | pie | na))  &  ((1 << n) - 1): 左边括号取反前表示col pie na中只要有1的位置, 都不能再放置皇后, 取反后就变成了`(~ (col | pie | na)) `二进制位中为1的位置才能放置皇后, 因为N皇后问题只有n列, 而int32位取反后高位多了很多1, 通过`&  ((1 << n) - 1)`运算消除高位无效的1

**前面不是规定了1位置表示已放置皇后, 为什么尝试放置时, 又要使用1位置表示能放置皇后的位置呢?**

p中为1的位置表示可以存放皇后的位置, 每次利用`cur = p & -p`取到p最右侧的1, 然后用cur对col pie na分别做或运算(指定位置置1), 就能模拟放置皇后

S：注意逻辑运算和位运算不要混淆；对常见位运算的作用要熟悉；位运算优先级很低，注意带括号

````java
public static int nQueen(int n) {
    if (n < 2) {
        return n;
    }
    return nQueen(0, 0, 0, 0, n);
}
private static int nQueen(int row, int col, int pie, int na, int n) {
    if (row == n) {
        // 走完了n行,表示一种可行方法
        return 1;
    }
    int cnt = 0;
    // p二进制位中为1的位置表示目前行可以放置皇后的列位置
    // 因为int数有32位,所以要去掉高位中无用的1,只取最低的n位
    int p = (~(col | pie | na)) & ((1 << n) - 1);
    // 只要p中1没有"消耗"完,表示可以继续尝试
    while (p > 0) {
        // curCol表示取出p中最右的1位置,用它去模拟放置皇后
        int curCol = p & (-p);
        // 模拟curCol位置放置皇后
        cnt += nQueen(row + 1, col | curCol, (pie | curCol) << 1, (na | curCol) >> 1, n);
        // 去掉p中最右侧的1(因为上面已经模拟放过了)
        p &= p-1;
    }
    return cnt;
}
````

