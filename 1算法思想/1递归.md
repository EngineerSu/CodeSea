## 递归

### 目录

**概念**

* [Master公式](#Master公式)

**基础**

* [汉诺塔问题](#汉诺塔问题)
* [辅助空间O(1)反转栈](#辅助空间O(1)反转栈)
* [打印九宫格数字匹配的所有字符串](#打印九宫格数字匹配的所有字符串)

**复杂**

* [正则表达式匹配](#正则表达式匹配)
* [打印和为定值的二叉树路径](#打印和为定值的二叉树路径)



### Master公式

[目录](#目录)

master公式是一个时间复杂度的递推公式,指的是当前规模(N)的任务拆分成若干个(a)**相同规模**(N/b)的子任务,每次任务还需进行一个复杂度为O(N^d^)的操作.

![1564794395188](img/1递归/1564794395188.png)



### 汉诺塔问题

[目录](#目录)

Q: 三个杆,有n个盘(小压大的顺序),要求将这n个盘从最左杆移动到最右杆(保持相同的顺序),要求移动过程中所有杆上的盘都只能小压大,不能大压小

A: 记三个杆为left, mid, right. 首先将left的n-1个盘移动到mid上, 这个操作和原问题的条件是一模一样的, 只是规模从n变成了n-1; 然后将left的最大盘移动到right上, 这一步是可以直接操作的; 最后将mid上n-1个盘移动到right上, 和原问题也是一样的条件, 只是规模变成了n-1.

```java
// 汉诺塔的递归非常美 -> 打印移动方法,返回总的移动步数
public static int movePlates(int N, String from, String help, String to) {
    if(N == 1) {
        System.out.println(from + "->" + to);
        return 1;
    }
    int step1 = movePlates(N-1, from, to, help);
    System.out.println(from + "->" + to);
    int step2 = movePlates(N-1, help, from, to);
    return step1 + 1 + step2;
}
```



### 打印九宫格数字匹配的所有字符串

[目录](#目录)

Q: 给定一个字符串str,每个字符范围是'2'~'9',打印整个字符串所有可能匹配的字母组合

A: 题目本身很简单,就是考察递归的写法.每个字符数字有3或4个选择的字母可以匹配,每个字符第一个可以匹配的字母由offset决定.(8对应了4个字母)

Example:

```
Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

![1564794420997](img/1递归/1564794420997.png)

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        
        List<String> list = new ArrayList<>();
        if(digits == null || digits.length() == 0){
            return list;
        }
        
        char[] charArr = new char[digits.length()];        
        process(0, charArr, digits, list);
        
        return list;
    }
    
    public static void process(int p, char[] charArr, String str, List<String> list){
        if(p == str.length()){
            list.add(new String(charArr));
            return;
        }
        
        int offset = str.charAt(p) >= '8' ? 1 : 0;
        int n = str.charAt(p) == '7' || str.charAt(p) == '9' ? 4 : 3;
        
        for(int i = 0; i < n; i++){
            charArr[p] = (char)((str.charAt(p)-'2')*3 + 'a' + i + offset);
            process(p+1, charArr, str, list);
        }      
    }
}
```



### 正则表达式匹配

[递归目录](#目录)

Q: 给定字符串str和exp, str中不包含'.'和'*', exp中可能包含'.'和' *', 其中'.'可以匹配一个任意数量的字符,' X *'可以匹配0个或若干个X. *不能是exp的首字符,也不能有连续的两个 *. 给定str和exp,判断exp是否能匹配str

如: .*可以匹配任意字符串 `.a *`可以匹配至少含有一个字符的任意字符串

```
核心判断条件  ei位置后面是不是'*'!!!
如果没有*: 那么必须让当前si位置能和ei位置匹配上,才能si++,ei++, 继续判断
如果有*: 只要si位置能和ei位置匹配，就有多了一种匹配的可能（si++）。如果这个*匹配的所有可能如果都失败,那只能继续往下:si跳到第一个和ei不匹配的位置,ei跳过这个*，然后重新开始匹配. 
	
第二种情况如下图:part1和part2匹配有5种可能:0~4个A都有可能
	part1中0个A和part2匹配, part1中从第一个A开始 与 part2后面的匹配 (1)
	part1中1个A和part2匹配, part1中从第二个A开始 与 part2后面的匹配
	part1中2个A和part2匹配, part1中从第三个A开始 与 part2后面的匹配
	part1中3个A和part2匹配, part1中从第四个A开始 与 part2后面的匹配
	part1中4个A和part2匹配, part1后从B开始 与 part2后面的匹配 (5)
```

![1564794447989](img/1递归/1564794447989.png)

```
// 动态规划思想
从这个递归中可以看到,其依赖与process(str, exp, si+1, ei+1) 和 process(str, exp, si, ei+2)
即以si和ei做一个二维结果表,(0,0)点是要求的结果点,其中所有的点都依赖于右下方的结果点
所以利用base-case从右下方开始求起,逐渐求到(0,0),就是一个动态规划
```

```java
class Solution {
    public boolean isMatch(String s, String p) {
        if(s == null || p == null){
            return false;
        } 

        return process(s, p, 0, 0);
    }

    public static boolean process(String str, String exp, int si, int ei){
        if(ei == exp.length()){
            return si == str.length();
        }

        // ei位置没有后一个元素 或 后一个元素不是 '*'
        if(ei+1 == exp.length() || exp.charAt(ei+1) != '*'){ 
            return si != str.length() && (str.charAt(si)==exp.charAt(ei) || exp.charAt(ei)=='.') && process(str, exp, si+1, ei+1);
        }

        // 继续执行,表明ei位置不是最后一个元素 且 ei+1的位置是'*'
        // 然后根据str和exp的元素决定它能有多少种匹配可能
        while(si != str.length() && (str.charAt(si) == exp.charAt(ei) || exp.charAt(ei)=='.')){
            if(process(str, exp, si, ei+2)){
                return true;
            }
            si++;
        }

        // 走到这里说明*匹配的所有可能都失败了,这里包含了多种可能:
        // 1.ei+1位置是'*',但是ei位置的字符和si位置的字符不匹配,即这个*匹配数量为0
        // 2.ei+1位置是'*',将si位置开始所有与ei位置相等的值都匹配了,即这个*匹配数量达到了最大值
        // 3.si位置已经到了str.length(),但是因为ei一直是X*的模式,所以可以继续到这里
        return process(str, exp, si, ei+2); 

    }
}
```



### 打印和为定值的二叉树路径

[目录](#目录)

Q: 打印和为定值的路径, 路径:根节点到叶节点所经过的所有节点

A: 其实就是遍历寻找二叉树所有路径的过程, 只是在遍历到叶节点时, 需要验证是否和为定值, 所以需要一个stack存储当前路径, 当离开这个节点时, stack弹出这个节点.
即stack实时更新当前路径,当记录到叶节点时,统计路径和.决定是否打印

```java
public void printAllPathInBT(Node head, int target) {
    if (null == head) {
        return;
    }
    Stack<Node> stack = new Stack<>();
    printAllPathInBT(head, stack, target);
}
private void printAllPathInBT(Node head, Stack<Node> stack, int left) {
    if (null == head) {
        return;
    }
    stack.push(head);
    left -= head.val;
    // 到达了叶子节点,且和为指定值,需要打印当前路径
    if (null == head.left && null == head.right && left == 0) {
        Stack<Node> temp = new Stack<>();
        while (!stack.isEmpty()) {
            temp.push(stack.pop());
        }
        while (!temp.isEmpty()) {
            // 打印并还原stack
            System.out.println(temp.peek().val + " ");
            stack.push(temp.pop());
        }
    }
    // 没达到叶子节点,继续往左孩子遍历
    if (null != head.left) {
        printAllPathInBT(head.left, stack, left);
    }
    // 没达到叶子节点,继续往右孩子遍历
    if (null != head.right) {
        printAllPathInBT(head.right, stack, left);
    }
    // 递归出节点时还原进节点前的状态
    stack.pop();
    left += head.val;
}
```



### 辅助空间O(1)反转栈

[目录](#目录)

Q: 将栈的元素顺序反转, 要求空间复杂度为O(1)

A: 不能用辅助栈,那么就用递归实现. 本质是利用了虚拟机帮你压栈

```java
// 递归:不断弹出最后一个元素,弹完开始存入
public static void reverse(Stack<Integer> stack) {
    if(stack.isEmpty()) {
        return;
    }
    int last = getLast(stack);
    reverse(stack);
    stack.push(last);
}
```

