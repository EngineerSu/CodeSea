# 刷题总结

## 数据结构

### 数组

#### 打印

将全打印分成 n 个相同的简单打印步骤，打印完第 i 次，继续打印第 i + 1次

#### 搜索

- 有序矩阵搜索：从右上角开始搜索，与边界比大小可以确定后续的搜索方向
- 出现超过一半的数：用一个键值对（num:count）可以搞定，是因为超过一半，count 可以抵消运算

#### 子数组

- 子数组最大和：累计和如果小于 0，则重新开始累加，否则继续累加（res，sum 两个变量即可）
- 和为定值的最长子数组：1.新的 sum 数组求从 0 开始的连续和（做差即是子数组和）；2.用 map 存每个连续和第一次出现的位置（和为 0 的最开始位置应该是 -1）；3.一些问题可以转换为和为定值的最长子数组
- 不包含重复元素的最长子数组：1.双指针；2.用 map 存储每个元素最新出现的位置；3.当 p2 所在元素前面出现过并且前面出现的位置在 p1 后面，则 p1 需要跳位置；遍历一次直至 p2 出界即可

#### 全排列

- 全排列的下一个排列：1.倒序寻找破坏递增的第一个数；2.倒序寻找第一个大于破坏递增性数的数，交换位置；3.破坏递增数后的所有数倒置



### 哈希表

map 的特点是存储映射关系，难点是找到有价值的映射关系

#### 拷贝 random 指针链表

- 用 map 存原 node 与 复制 node 的映射关系
- A - A' - B - B' - ... 可以节省 map，但是要两次遍历完成拷贝

#### 单词替换字母形成新单词

- 一个单词去掉一个字母，可以形成多个残缺部分，以这些残缺部分为 key，单词为 value，则组建了一个可以解决问题的索引
- 对单词进行拆分，然后根据索引快速找到可以替换的单词



### 链表

#### 翻转

- 反转操作可以用几个 node 变量细致完成，也可以用栈直观完成
- 单链表相加：本质也是先翻转再相加，再翻转
- 每 k 个点翻转：先找到 k 个点，然后翻转，然后用原 head 指向剩下待翻转的链表（递归）
- 回文判断：1.用栈直观完成；2.走一半翻转完成（链表找中点，用快慢指针）

#### 有环/相交

- 环：1.直观用 set 完成；2.O(1) 用快慢指针完成
- 相交：1.无环相交；2.有环同入环点；3.有环不同入环点相交（沿着一个入环点走能找到另外一个，则相交）

#### 排序

- 归并、partition（三个区的头尾节点，增加 6 个变量）、插排（用新链表承接）
- 合并 k 个链表：两两合并，logN 的数量



### 树

#### 遍历

- 递归：相对简单
- 非递归：DFS 要学会压栈
- 层遍历：BFS 使用队列；求最短长度就是层遍历找到第一个左右儿子都为 null 的

#### 反序列化

从反序列化数据取出来的元素，当它的左右儿子没确定时，需要考虑用新的容器存着，遍历是用原数组遍历，还是用暂存容器遍历，需要考虑

- DFS：前序使用递归比较简单；非递归时，对于左右儿子没确定的节点，要用栈暂存
- BFS：对于左右儿子没确定的节点，用队列暂存

#### 判断

- 平衡：递归求树深度，是平衡返回深度，否则返回 -1
- 搜索：中序遍历结果为非降序
- 完全二叉树：层遍历看儿子节点
- 对称二叉树：中左右 与 中右左遍历结果一致
- 搜索二叉树的后序遍历：抓住后序最后一个节点是 root，找到它的左右子树对应的数组，再递归判断

#### 打印

- 按层：层遍历，加几个变量，记录层数、当前层剩余节点数和下一层节点数
- 之字型：层遍历，但是用两个栈（pushStack、popStack）实现整体 FIFO，局部 FILO

#### 其它

- 完全二叉树节点个数：通过深度判断左右子树是否满二叉树，若是则该子树节点个数可以直接用公式计算
- 累加和为定值的最长路径：DFS，需要带入递归的有：target、preSum、level、res，用的是和为定值最长子数组的思路，用 map 存累加和第一次出现的位置（注意：1.累加和为 0 的位置要确定；2.递归退出当前层的时候，判断当前层累加和是否在 map 中，若在则要退出去）
- 两个节点的公共祖先：1.将两个节点从树中剥离一个 DFS 链表出来；2.求这两个链表的交点
- 前缀树：每一个节点有 end 和 count 两个变量，作为大型字符串集索引的一种，用于查询/统计大数据中，某种前缀特征的字符串



### 栈

#### 栈的实现

- 数组实现栈：用 size 可以满足容量、push、pop
- 队列实现栈：两个队列 storage、help

#### 最值栈

- 除了栈本身，还要维护最值栈，在每次 push/pop 时，同步操作最值栈

#### 单调栈

栈底到栈顶满足单独递增（递减）规则，遇到相等的是继续压栈，还是弹栈或更新栈顶元素，需要看实际应用。

单调栈内存储信息看实际情况，不局限于元素大小、索引位置和出现次数等。它的特点是可以找到序列中离元素最近，比它大/小的元素

- 数组元素最近较大/小值：单调栈最直接的应用
- 数组直方图的最大长方形：单调栈的有趣应用
- 最大子矩阵：矩阵每一行都可以认为是一个数组直方图，进行相似操作
- 环形数组烽火对：1.组成烽火对 （a, b） 的有两种，一是 a < b，二是 a = b（不同烽火台，但是高度相等）；2.单调栈从最大值开始压栈，保证栈底上面所有元素两边都有比它大的值；3.单调栈存储的是元素索引位置，以及出现次数，对于非倒数第一、第二的两个元素，它们在出栈时的烽火对个数计算公式为：C(k, 2) + 2*k（其中 k 为元素重复出现次数）

#### 括号匹配

- 是否为合法的括号字符串：左括号压栈，右括号弹栈，如果弹栈时栈为空则不合法，遍历完后，栈不为空也不合法
- 最长匹配括号子字符串：一样左括号压栈，右括号弹栈，若成功弹栈，则需要记此时的匹配子串长度：右括号索引 - 栈顶元素索引，如果此时栈为空，则是右括号索引 - start，start 值在每次开启合法匹配的左括号压栈底时更新



### 堆

堆经常使用的是大根堆，小根堆，它们可以进行数据交换，PriorityQueue 默认是小根堆（升序比较器）

#### 实现

- 数组实现堆：上浮/下沉，上浮是只要儿子比父亲大，就一直往上找；下沉只要父亲比某个儿子小，就一直往下落。i 儿子父亲索引是 (i - 1) / 2，i 父亲的儿子索引分别是 2i + 1、2I + 2

#### 应用

- 数据流中位数：大根堆存较小的一半数，小根堆存较大的一半数，当 size 差超过 1 时，需要调整；取中位数时，只用关注两个堆顶即可
- K 次项目获利最多：贪心算法，每一次都需要找到当前可以做的收益最大的项目去做，将项目 node 以 cost 建小根堆，以 profit 建大根堆，不断将小根堆堆顶小于目前已有资金的项目移动到大根堆，直至不能移动时做大根堆项目



### 队列

#### 队列实现

- 数组实现：引入 offerIndex 和 pollIndex 执行对应操作，注意索引的循环使用
- 栈实现：两个栈 

#### 双端队列

双端队列使用 LInkedList，可以指定在队首/队尾进行 add/poll 操作，适用于做滑动窗口的最值管理

特点：

头部至尾部是单调的；取数从头部直接取最值；插入从尾部插入，插入前先 poll 掉违反插入后单调性的元素

一般存储索引值，通过索引是否在窗口内判断头部是否过期

- 滑动窗口最值：建立双端队列，在窗口滑动时，插入新数据，并去掉过期头部
- 最值差不大于 num 的子数组数量：p1, p2 双指针的窗口最值管理。满足条件的子数组内，所有子数组都满足；不满足条件的子数组被任何子数据包含时也都不满足；移动 p2 至不满足时，可以确定以 p1 为 起点的所有满足条件子数组，然后p1、p2都右移一步，继续寻找



### LRU

最近一段时间使用的放在头部，移除时从尾部开始

由一个 map 和一个 linkedList 实现，map 负责存储数据，linkedList  负责建立 key 的 LRU 关系（当 get/put 时，将相关 key 先 remove 再 addFirst，保证在头部），仅当 put 时元素数量超过了设置，并且 put 的 key 之前不存在时，才需要将末尾的 key 移除，并将其从 map 中也移除



## 算法思想

### 排序

#### 基本算法

3+3+1：3 个二次方，3 个 NlogN，1 个特殊排序

- 选择、冒泡、插排（插排是当前遍历位置往回冒泡，冒泡是对端位置冒泡到当前遍历位置）
- 归并（分成两部分再合并）、随机快排（小于区，等于区，大于区分好后，再继续分小于区和大于区）、堆排序（先建大根堆，每一个元素上浮，再每次将堆顶元素与数组最后一个位置交换，交换后，堆的 size 也减 1，然后将交换后的堆顶做下沉操作；）
- 桶排序：适用于数据元素个数一定的情况下



#### 常见应用

- 小和问题：因为 merge 左右位置不会被打乱，所以在 merge 中求类似小和问题是 ok 的
- 求第 k 大/小的数：，分小于区，等于区和大于区，如果 k 对应的索引落在等于区则命中，否则也可以指导缩小范围
- 数组排序后的最大相邻差：桶排序应用，分 N+1 桶，至少有一个桶会没有数。分桶完成后，遍历桶，将每个桶内最小值减去上一个桶内最大值



### 递归

#### 基础

- 汉诺塔问题：大问题拆分成若干子问题后，能用递归一定得保证，子问题和大问题是一样的解法（条件一致，寻求结果一致）
- 辅助空间 O1 翻转栈：会用到两种递归，第一种递归是取出栈底元素；第二种递归是先取出栈底元素，把剩下栈翻转，再把栈底元素 push

#### 二叉树递归遍历

- 删除二叉树中值为0的叶子节点：递归的时候，需要注意先处理左右儿子，因为可能本来不是叶子节点，儿子处理完后就变成要删除的叶子节点了；另外删除动作是在上一层执行的，所以需要告知上一层节点是否要被删
- 二叉树中节点数最多的搜索二叉子树：应该先判断左右儿子是否为搜索二叉树，如果是，那么要是满足左子树最大值小于 head，head 小于右子树最小值，那么当前层的搜索二叉树节点数量就是左+ head + 右；否则当前最多的搜索二叉树节点数是左右子树较大值。这里有一个难点，就是如何判断“左子树最大值小于 head，head 小于右子树最小值”，这个信息需要递归带给上一层，如果放在递归结果里会增加递归的复杂度，所以可以考虑使用全局变量 max、min 和 count 来记录在 DFS 的时候，二叉搜索树最大值、最小值以及节点数；全局变量在每次局部递归后，可以用局部变量缓存，比如 leftMax...

#### 笛卡尔积

- 表达式加任意括号的结果集：遍历当前字符串，只要是运算符，就给它分成两部分递归计算结果，然后计算它们的笛卡尔积。base case 是没有运算符的字符串就是数值大小
- 字符串 ip 地址：找到一个合格的 ip 地址数，然后剩下的递归成三位 ip 地址数，做笛卡尔积。（0 开头时只能做一位）
- 字符串依照字典拆分所有句子可能：对字符串进行遍历，当遍历到的位置在单词列表中出现时，就可以分成两部分，一部分是已知单词，另外一部分则递归求解，对两种求笛卡尔积。判断字符串是否在单词列表中出现时，可以将单词列表排序，并利用字符串长度做剪枝。
- 求 1~n 中 1 出现的次数：没有用递归，但是是笛卡尔积。考虑固定每一个进制位为 1 时，考虑进制位两边的可能性，它们可能性的乘积即是 n 范围内，这个进制位为 1 的数字个数，考虑完所有进制位，这些数字个数的累加和即是答案。

#### 其它

- 字符串的正则匹配：s 是字符串，p 是正则串，分别用 p1, p2 来表示目前匹配指针的位置，如果 p2 走出界，表明匹配成功，如果 p1 走出界，还需要继续匹配，因为 p 可能包含 `*` ，一个特殊的符号。在每次匹配时，核心也是判断 p2 后面是否有一个 `*` ，如果有匹配规则就会变得复杂，如下：

  - 无论 p1,p2 当前是否匹配，`*` 的存在都可以尝试让 p1 与 p2 + 2 的位置重新开始匹配
  - 如果 p1 和 p2 匹配，为了不浪费 p2 后的 `*` ，可以让 p1 +1 开始与 p2 匹配

  另外，为了避免重复计算，可以用一个缓存来缓存递归结果，维度就是 p1,p2

- 岛问题-标记递归：第一次发现岛时，就将所有岛元素染色，避免后续重复登记



### 分治

分治的核心是要找到方法，不断将问题规模缩小，最终夹逼出正确解。

#### 基本二分

二分的基本思想是一直把结果限制在 [left, right] 之间，通过 mid 位置处的判断，不断缩小 [left, right] 的范围。常见的二分有两种：

- left 和 right 是索引位置，典型的比如在排序数组中寻找是否寻找某个数
- left 和 right 是数值，典型的比如在有序矩阵中寻找第 k 大的数

简单题目：

- 求 x 平方根：注意 int 型数相乘可能会越界
- 数字在排序数组中出现的次数：求左右边界
- 旋转递增数组中查找某个数：通过 mid 判断有两种可能：要么仍然去旋转数组中查找；要么就是在有序的一半中查找

#### 第 k 小/大的数

- 无序数组第 k 大的数：partition，小于区等于区大于区，第 k 大的数索引落在不同区时都会减少搜索范围

- 两个有序数组第 k 大的数：用 p1,p2 俩个指针分别表示两个数组的搜索位置，每一次排除 k/2 个数，排除原则是：

  - 某数组剩下元素数量不到 k/2，则直接排除另外一个数组 k/2 个数
  - 两个数组剩下元素数量都大于 k/2，那么看两个数组 k/2 的位置大小，谁小谁排除

  直到某一个数组排除完（变成在一个有序数组中寻找第 k 大的数，可以直接得到），或者 k 降为 1

- 两个有序数组的中位数：求两次第 k 大的数，即可得到中位数

- 有序矩阵中第 k 大的数：有序矩阵的最小值和最大值易知，作为 left 和 right（值），求 mid，通过 mid 值在有序数组中的第 count 大，比较 count 和 k 来决定下一个 left 和 right，不断夹逼，直到 left == right 即是结果。有两点注意：

  - 求有序数组中比 mid 值小的 count 时，应该从左下角开始比较，优势是比较的纵坐标只降不升
  - 这个方法缩小的是值范围，不是问题规模数，所以 k 不用减小



### 双指针

- 整数表示为连续自然数的和：典型的双指针，p1开始是1，p2开始是2，开始走并计算p1 ~ p2之间的和，若和小了则p2++，若和大了则p1++，直到p1 == p2，或者p2 == n。这个问题跟有序子数组和为定值是一样的，只是这样描述显得陌生一点。
- 2 sum：p1 p2 分别置于首部、末尾，根据和的情况判断
- 蓄水池问题：找两个柱子作为左右边界，求最多盛水。p1, p2 从首尾两侧开始，每次往中间移动较小的位置，过程中求最大蓄水量。
- 接雨水问题：木头桩子会占据雨水空间。A1：p1, p2 放在两边作为容器两侧，每次移动较小一侧，判断移动后的位置是容器新的一侧（高度要大于之前容器两侧的较小值），还是用来盛水的？求累计盛水量（A1 思路核心是每个柱子要么作为容器两侧，要么用来盛水）A2：一个柱子能盛水的前提是，这个柱子左右两侧都有比它高的柱子，盛水量=左右两侧较低值-柱子高度，所以求两个数组 left[i] 和 right[i]，分别表示在 i 左侧的柱子最高值和在 i 右侧柱子的最高值
- 第 1500 个丑数：用 p2 p3 p5 三个指针，分别表示 pi*arr[i] 会比当前最新的丑数大，每次取这三个值中最小的，并且更新指针
- 不重复的最长子串：p1 p2 两个指针找子串，用一个 map 存（元素值，元素值最后出现的位置），如果 p2 值在 map 中出现，则将其与 p1 比较，判断 p1 是否移动（当在 p1 左侧时是不需要移动的！！）
- 种类不超过 k 的最长子字符串：用两个 map，第一个 map 存（元素值，元素值最后出现的位置）；第二个 treeMap 存（元素值最后出现的位置，元素值），treeMap 需要跟 map 一起同步更新，它存在是为了找到 map 中最小的 value 值。p1 p2 两个指针找子串，当 p2 位置使得 map 的 key 值种类超过了 k，就要找到 map 中 value 最小的位置，如果此位置 >= p1，那么 p1 要右移，保证 [p1, p2] 之间种类不超过 k



### 位运算

#### 常见位运算

```
n & -n  =>  得到n最低位的1(如10100，得到00100)
n & (n-1)  =>  消除n最右侧的1(如10110, 得到10100)
异或运算：与本身异或恒为 0，与 0 异或恒为本身
```

#### 应用

- 判断某二进制数有多少个 1：不断 `n & (n-1) ` 做运算，直至为 0 即 1 的个数。关联子问题：
  - 判读两个数的二进制位有多少位不同：先做异或运算，然后求结果有多少个 1
- 数组中两个只出现一次的数：整个数组做异或运算，得到的数是两个只出现一次数的异或运算结果，将结果做 `n & -n ` 运算得到判断数，与判断数异或为 0 的分一组，为 1 的分一组，两组分别异或结果即是要找的两个数
- 用位运算做加法：^ 运算相当于无进制的加法，& 运算后左移 1 位是求进位
- N 皇后：pre col na 分别是三个整型数，其中为 1 表示的已经放了皇后，每次需要根据 pre col na 计算出可以放皇后的位置（或、取反再做位运算，仅保留 n 位），每次取出最右的 1 位（n & -n），模拟放置皇后递归的到下一页



### 贪心

局部最优解，获取整体最优解，很多时候无法证明。

- 字符串集合的最小字典序：构建比较器：`(o1 + o2).compareTo(o2 + o1)`
- 哈夫曼编码/分黄金问题：用小根堆，每次选堆顶最小两个值出来组合，然后再放回堆顶
- 用最少的箭射爆最多的气球：将气球区间按右侧进行升序排列，每次取出一个最小的右侧进行射击，气球后面左侧小于该右侧则都会被这个箭射中
- 分组差的最小值：计算组和的一半，将其排序，顺序凑一遍（凑的和不超过一半），凑完计算差值；反序再凑一边，同样计算差值，两者较小者即为答案。
- 小孩分糖果：正序来一遍，保证从左往右看的时候，权重大的孩子糖果多；反序来一遍，保证从右往左看的时候，权重大的孩子糖果多
- 跳跃游戏：在第 i 个位置时，当前能达到的最远位置为 i+arr[i]，假设跳到了位置 j ：`i+1 <= j <= i+arr[i]` ，j 选择的标准是看哪个 `j + arr[j]` 最大，就选哪个



### 回溯

回溯是在递归里循环，求解排列组合问题。回溯的时候注意：

- 元素是否可重复选择，
- 元素列表本身是否有重复元素：若有，则需要在将其排序，每次选择元素前，判断前面元素是否与其相等且未使用，若是，则当前元素也不能使用

#### 基础

- 给 n 对括号，求所有合法括号字符串组合：每次递归选择就是放左括号还是右括号，如果已经放置的左括号数大于右括号数，才能放右括号；左括号是可以随时放的。base case 是左括号或右括号放满了 n 个
- 和为定值的二叉树路径：递归遍历的时候，用栈存储遍历路径，注意 push 和 pop

#### 搜索

- 二维矩阵搜索单词：每个字符都可以作为起点尝试去上下左右搜索单词，base case 是当前位置匹配，并且到了单词最后一个位置。因为用过的不能使用，所以需要用一个数组标，进入的时候标记，退出的时候清除

#### 排列组合

- 全排列：递归内循环数组，用一个布尔数组标识元素是否用过，没用过则都可以采纳。当原数组有重复数字时，使用布尔数组去重
- 最简单的组合：数组内无重复数，要求数字不能重复使用，且组合无顺序。对数组进行排序，递归中每次遍历从上次遍历过位置的下一个位置开始遍历
- 要求有顺序的组合：在上面的基础上，要求输出组合有顺序概念。则递归内每次遍历所有元素，通过布尔数组标识来判断当前元素是否被采用过。
- 有重复元素的组合：使用布尔数组+重复元素只能优先靠前使用概念去重
- 有重复元素并且可以重复选取：递归中每次遍历从上次遍历过位置开始遍历
- 子集：对原数组进行排序，遍历到每个位置时有两个选择：选当前元素或不选，选的时候要满足使用布尔数组+重复元素只能优先靠前使用概念去重



### 动态规划

动态规划适用于求：方案总数/是否有可能/最多/最少等情况

动态规划步骤：
- 找一下哪些是变量（可以变化的状态）
- 给出 dp[i] 或 dp[i][j] 的含义，其中 i 和 j 分别表示什么，dp 整体又表示什么
- 思考由确定的 dp 含义，怎么得到最终结果？如果不能得到结果，则说明 dp 含义确定的有问题
- 根据 dp 的含义，推导递推式，推导的过程往往是从 dp[i-1] 或 dp[i-1][k] 出发去思考，如何得到 dp。由 dp[i-1] 得到 dp[i] 是取最值，还是取和或其它关系式，是根据 dp 实际含义来确定的！！
- 确定 dp 的 basecase，一定要根据实际含义认真思考，避免因为 basecase 错误，导致整体答案错误

#### 斐波那契数列

- 爬楼梯：最后一层要么是从倒数第二层上，要么是从倒数第三层上。
- 强盗抢劫：从最后一家角度看，要么抢了要么没抢，dp[i] 表示抢劫完第 i 家后的最大收益，递推式为：`dp[i] = max{dp[i-1], dp[i-2]+nums[i]}`
- 强盗抢劫-环形街区：考虑第一家和最后一家的抢劫情况，可以把问题变成直街区
- 母牛生产：dp[i] 表示第 i 年的牛数量，今年的牛 = 去年的牛 + 三年前牛的数量

#### 矩阵路径

- 矩阵左上角到右下角的最短路径和：`dp[i][j]` 表示从左上角移动到 (i, j) 处的最短距离，先求最左列和最上行做 basecase
- 矩阵左上角到右下角的总路径数：如果每个单元格都可以走，则是在 M+N 步里，选 M 步右走。有了障碍后，则类似于上面

#### 简单 DP

- 分割整数的最大乘积：dp[i] 表示 i 分割整数的最大乘积，则有 `dp[i] = max(max(dp[i - j] * j, (i-j) * j))` 其中 `1 <= j < i` ，注意 `(i-j) * j` 也是需要比较的
- 按平方数分割整数的最少数量：注意 int 类型数相乘会越界，选用 long 类型数组
- n 个骰子和的所有次数统计：`dp[i][j]` 表示投 i 个骰子，和为 j 的次数

#### 寻找规律

- 复制粘贴A的最少次数：dp[i] 表示得到 i 个 A 的最少操作次数，`dp[i] = j + dp[k] (i = j * k)` ，j 的范围是是 `2 <= j <= Math.sqrt(i)` ，在 j 范围内找最小值

- n 构成二叉搜索树：任选一个节点作为头节点，则其左侧是左子搜索树，右侧是右子搜索树，两者乘积是以该节点为头节点的总二叉搜索树个数

- n 构成二叉搜索树II（返回所有列表）：用递归去做，递归变量是构成二叉搜索树的左右区间，一样的思路。

- 比特位计数：因为要计算每个数的二进制位中 1 的个数，所以每个数都做位运算是不合适的，规律是 `dp[i] = 1 + dp[i - 2^j]` 其中 `2^j` 是小于 i 的最大 2 的 n 次方数，这样可以复用前面算的 1 的数量

- DI 序列的有效排列：`dp[i][j]` 表示遍历到第 i 个 DI 序列后，以 j 结尾的有效排列个数，它的递推式为：

  - ```
    dp[i][j] = dp[i-1][k] (当 S[i-1] = D 时，k >= j；反之, k < j)
    ```

  注意理解真实的排列怎么由 `dp[i-1][k]` 变化到 `dp[i][j]` ；注意取模用 long 类型不要用 double，并且所有中间计算结果都可以取模

- 取数游戏：假设在 `[m, n]` 区间内，A 先选了第 m 个数，那么下一次 A 再选数的区间两种可能：`[m+1, n-1]` 或 `[m + 2, n]` ,问题就变成了在这两个选数区间中求较大值，所以变成了递归问题，为了避免重复计算，可以使用一个 m*n 的二维数组来缓存结果。

- 猜数字出钱游戏：在区间 [i, j] 中设了一个要猜的数 f，假设第一个猜的是 k，那么 f 可能在 k 左侧，也可能在 k 右侧，计算最坏情况，要出的钱为 `k + Math.max(dp[i, k-1], dp[k+1, j])` ，在 `i <= k <= j` 的范围内，上述公式求出来的最小值，即是游戏要赢的最少成本

#### 子数组

- 等差递增子数组个数：dp[i] 表示以 i 结尾的等差递增子数组个数，则有 `dp[i] = dp[i-1] + 1` ，条件是 `arr[i] - arr[i-1] = arr[i-1] - arr[i-2]` ，不满足条件时，dp[i] = 0，所有 dp[i] 的和即是答案。这个题也可以用双指针做，就是要稍微细致一点
- 子数组的最大乘积：用 max[i] 和 min[i] 记录遍历完第 i 个元素后的最大值/最小值，它们的更新需要根据 arr[i] 的符合使用不同关系式，另外都是跟元素值本身比较大小，如果选用的是这个元素本身，表示子数组从当前元素开始累积
- 最长完美子数组：dp[i] 表示以第 i 个元素结尾的最长完美子数组长度，它与 dp[i-1] 的关系需要计算判断。另外，这题也可以用双指针去做

#### 子序列

- 最长递增子序列：dp[i] 表示以第 i 个元素结尾的最长递增子序列长度，则在 i 前面的位置 j 只要 nums[j] < nums[i]，就有 dp[i] = dp[j] + 1，求这些最大值
- 最长整除子集：dp[i] 表示以第 i 个元素结尾的最长整除子集，将数组排序，则在 i 前面的位置 j 只要 nums[j] % nums[i] == 0，就有 dp[i] = dp[j] + 1，求这些最大值。并且为了还原最长整除子集，可以用一个数组记录每个 dp[i] 最大时的 j 值，最后从最大的 dp 开始就能串起来。
- 最长摆动子序列：up[i]、down[i] 分别表示以 nums[i] 结尾且最终递增/递减的最长子序列长度，去 i 前面找递推关系式

#### 双序列

- 最长公共子序列：`dp[i][j]` 表示 str1 前 i 个位置与 str2 前 j 个位置的最长公共子序列，递推关系式为：

  - ```
    dp[i][j] = dp[i-1][j-1] + 1 (当num1[i] == num2[j])
    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) (当 num1[i] != num2[j])
    ```

  - 子问题：删除最少的字符，使两个字符串相等

- 最长公共子串：`dp[i][j]` 表示以 str1 第 i 个位置结尾与 str2 第 j 个位置结尾的最长公共子串，递推关系式为：

  - ```
    dp[i][j] = dp[i-1][j-1] + 1 (当num1[i] == num2[j])
    dp[i][j] = 0, dp[i][j-1]) (当 num1[i] != num2[j])
    ```

  - 注意 dp 含义与最长公共子序列已经不一样了！另外最终结果与 dp 的关系也因此变得不一样

- 编辑字符串使它们相等：`dp[i][j]` 表示 str1 前 i 个位置与 str2 前 j 个位置相等需要的最少编辑次数，递推关系式为：

  - ```
    dp[i][j] = dp[i-1][j-1] (当num1[i] == num2[j])
    dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1 (当 num1[i] != num2[j])
    ```

  - 递推关系式分别对应三种编辑动作

#### 其它

- 鸡蛋掉落判断楼层：N 层楼，K 个鸡蛋，0 <= F <= N，F 上的楼层摔蛋会碎。`dp[i][j]` 表示有 i 个鸡蛋，判断 j 层楼需要的最少扔鸡蛋次数，递推关系式为：

  - ```
    dp[i][j] = min(max(dp[i-1][m-1], dp[i][j-m]) + 1), 其中 1 <= m <= j
    ```

  - m 表示选择在第 m 层扔一次蛋，m 是可以自己选择的，所以在 m 的范围内，求递推式的最小值。`dp[i-1][m-1], dp[i][j-m]` 分别表示在第 m 层扔蛋碎了和没碎需要的仍然次数，因为 F 是随机的，所以这两者需要取最大值

  - 蛋没碎时，表明 F 的范围是在 [m, j] 之间，两边同时减去 m，得到 [0, j-m]，所以对应需要的扔蛋次数是 `dp[i][j-m]`

  - 当 i 和 j 确定时，`dp[i][j]` 在求解时，可以用二分法来降低时间复杂度

  - 如果鸡蛋足够多的话，用二分法是扔蛋次数最少的

- 数字字母解码：dp[i] 表示遍历到 i 个数字后能解码的最多字符串数量，需要根据第 i 个和第 i-1 个字符，来确定 dp 的递推关系式：

  - ```
    dp[i] = dp[i-1](当第i个数字可以单独构成一个字母时) + dp[i-2](当第i个数字和第i-1个数字能够一起构成一个字母时)
    ```

- 格雷码：特点是上一个格雷码序列最高位增加一个 1，再倒序接在原序列后面，就形成了下一个格雷码序列

- n 次骰子最大值的期望值：`dp[i][j]` 表示扔完第 i 个骰子后，最大值为 j 的概率。它的递推关系式为：

  - ```
    dp[i][j] = dp[i-1][j] * 第 i 次骰子值不大于 j 的概率 + dp[i-1][k] * 第 i 次骰子值为 j 的概率（1 <= k < j）
    ```

#### 股票交易

一个数组表示股票每天的价格，求最大收益

- 只能交易一次：min 记录遍历到当前位置的最小值，所有当前值 - min 的最大值即最大收益

- 可以交易无数次：只要股价比前一天高，就交易拿取这部分利润

- 只能交易两次：用 firstBuy、firstSell、secondBuy、secondSell 转移方程

- 只能交易 k 次：`yesDp[i][j]` 和 `noDp[i][j]` 表示第 i 天交易了 k 次的最大收益，前者表示当天持有股票，后者表示当天未持有股票，递推关系式为：

  - ```
    yesDp[i][j] = max(yesDp[i-1][j], noDp[i-1][j-1] - nums[i])
    noDp[i][j] = max(doDp[i-1][j], yesDp[i-1][j] + nums[i])
    ```

  - 注意初始值的设置要满足 dp 的含义

- 能交易无数次，有手续费：交易无数次，则交易次数这个状态就没有了，`yesDp[i]` 和 `noDp[i]` 即可表示，递推式类似，只是在卖出的时候算了手续费

- 能交易无数次，有冷冻期：交易无数次，则交易次数这个状态就没有了，`yesDp[i]` 和 `noDp[i]` 即可表示，递推式类似，只是要考虑冷冻期内不能买

#### 背包问题

从一个物品列表中，在满足一定条件的情况下，取出若干物品。

- 01 背包/多维属性背包：物品只能取一次，条件是取的物品各属性总和要在背包承受范围之内
- 划分数组相等两部分/改变符号使数组和为定值：物品只能取一次，条件是取的物品属性和为定值
- 完全背包：物品可以取多次，条件是取出物品属性总和为定值或要求要某种顺序取出物品（字符串按单词列表分割）

题目如下：

- 01 背包问题：物品要么要，要么不要。用`dp[i][j]`表示遍历到第i件商品时, 重量不超过j的背包最大价值. 则有以下递推式:

  - ```
    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w] + v)
    ```

  - 子问题1：数组划分成相等的两部分

  - 子问题2：数组设置符号，使其和为定值 => 推导出来也是和为定值，`dp[i][j]` 表示遍历到第i件商品后, 背包和为 j 是否有可能，则递推式为：`dp[i][j] = dp[i-1][j] || dp[i-1][j-w]`

- 多维背包问题：dp 变成三维，可以缩减掉物品遍历的那一维，但是注意遍历的时候倒序遍历

- 完全背包问题：商品可以多选：1.商品仍然在外层遍历，但是内层在循环时，该商品可以多次使用；2.商品在内层遍历，由于没有布尔标记物品是否被选过，所以这种方式天然就是可以多选的。两者区别是 1 无序，2 有序

  - 找零钱的方案数：不讲究顺序，用第一种遍历方式。`dp[i][j]` 表示遍历完第 i 个硬币后，组成和为 j 的方案数

  - 找零钱的最少硬币数：由于要求的结果与顺序无关，因此可以用第一种方式做，也可以用第二种

  - 字符串按单词列表分割：换角度思考是从单词列表种，可重复的选单词，组成字符串，可见是有序的。用 dp[i] 表示字符串第 i 个及以前的字符是否能被单词列表拼接得到，则递推关系式为：

    - ```
      dp[i] = dp[i] || dp[i-word.length()] （word 可以是单词列表中每一个单词，但前提是 s.substring(i-word.length(), i+1) 与 word 匹配上）
      ```

  - 组合总数：与找零钱方案数基本一样，区别就是组合在乎顺序，所以采用内层遍历的形式



## 数学算法

### KMP

用于字符串匹配，找匹配串（str2）的最长前缀数组（next 数组），用 next 数组指导字符串匹配

- next 数组获取方法：next[0] = -1 next[0] = 0
- next 数组指导：匹配不上时，p2 优先回退到 next[p2]，直到 p2 == 0 还不匹配，p1 则要右移一位重新开始匹配

#### 子问题

- 字符串 str1 后面拼接最少的字符串，得到 str2，使得 str2 中有两个子串等于 str1



### Manacher

用于求最长回文子串，特点是前面最长回文子串的信息对后面求解有指导作用。

有三个重要的过程变量：

- r[] 数组：记录每个位置的最长回文半径
- maxR：记录遍历过程中，最长回文子串到达的最远位置
- C：记录遍历过程中，最长回文子串第一次到达最远位置的索引

当遍历的位置 i 在 maxR 左侧时，根据 C 的对称位置 i'，指导 i 的暴力扩半径，可以从 Math.min(maxR - i, r[i']) 开始

#### 子问题

- 字符串后面拼接最少的字符，使新字符串成为回文串



### BFS

当问题是要求满足某个条件的树的最低层次时，用 BFS 可能会更优。因为如果用 DFS 求某个最低层，需要跑完所有路径，如果树中存在较深路径，显然用 DFS 代价就很大。而 BFS 由于是逐层扫描，扫描到满足条件层即可停止。

- n 次后 A 不小于 B：用一个 node 包含 A 和 p，那么该 node 每次会分裂出两个分支，一个儿子的 A=A+p，一个儿子的 p=p*q，采用 BFS 可以避免因为 q 过小而导致过深的情况
- 倒水游戏-三杯：一个 node 包含 a,b,c（三个杯子水的实时量），初始值为 8 0 0，一个 node 下分时，最多有 6 种可能（x 往 y 倒水，x 有三种，y 有两种），但是要考虑：1.x 能倒完或 y 能倒满，这个可能才会出现；2.这种可能实施后的 a,b,c 在前面步骤种是否出现过（用 set 存储），如果出现过则不能再作为一种可能，否则就是走回头路，肯定不是最少步骤

