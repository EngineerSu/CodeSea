# 刷题总结

## 数据结构

### 数组

#### 打印

将全打印分成 n 个相同的简单打印步骤，打印完第 i 次，继续打印第 i + 1次

#### 搜索

- 有序矩阵搜索：从右上角开始搜索，与边界比大小可以确定后续的搜索方向
- 出现超过一半的数：用一个键值对（num:count）可以搞定，是因为超过一半，count 可以抵消运算

#### 子数组

- 子数组最大和：累计和如果小于 0，则重新开始累加，否则继续累加（res，sum 两个变量即可）
- 和为定值的最长子数组：1.新的 sum 数组求从 0 开始的连续和（做差即是子数组和）；2.用 map 存每个连续和第一次出现的位置（和为 0 的最开始位置应该是 -1）；3.一些问题可以转换为和为定值的最长子数组
- 不包含重复元素的最长子数组：1.双指针；2.用 map 存储每个元素最新出现的位置；3.当 p2 所在元素前面出现过并且前面出现的位置在 p1 后面，则 p1 需要跳位置；遍历一次直至 p2 出界即可

#### 全排列

- 全排列的下一个排列：1.倒序寻找破坏递增的第一个数；2.倒序寻找第一个大于破坏递增性数的数，交换位置；3.破坏递增数后的所有数倒置



### 哈希表

map 的特点是存储映射关系，难点是找到有价值的映射关系

#### 拷贝 random 指针链表

- 用 map 存原 node 与 复制 node 的映射关系
- A - A' - B - B' - ... 可以节省 map，但是要两次遍历完成拷贝

#### 单词替换字母形成新单词

- 一个单词去掉一个字母，可以形成多个残缺部分，以这些残缺部分为 key，单词为 value，则组建了一个可以解决问题的索引
- 对单词进行拆分，然后根据索引快速找到可以替换的单词



### 链表

#### 翻转

- 反转操作可以用几个 node 变量细致完成，也可以用栈直观完成
- 单链表相加：本质也是先翻转再相加，再翻转
- 每 k 个点翻转：先找到 k 个点，然后翻转，然后用原 head 指向剩下待翻转的链表（递归）
- 回文判断：1.用栈直观完成；2.走一半翻转完成（链表找中点，用快慢指针）

#### 有环/相交

- 环：1.直观用 set 完成；2.O(1) 用快慢指针完成
- 相交：1.无环相交；2.有环同入环点；3.有环不同入环点相交（沿着一个入环点走能找到另外一个，则相交）

#### 排序

- 归并、partition（三个区的头尾节点，增加 6 个变量）、插排（用新链表承接）
- 合并 k 个链表：两两合并，logN 的数量



### 树

#### 遍历

- 递归：相对简单
- 非递归：DFS 要学会压栈
- 层遍历：BFS 使用队列；求最短长度就是层遍历找到第一个左右儿子都为 null 的

#### 反序列化

从反序列化数据取出来的元素，当它的左右儿子没确定时，需要考虑用新的容器存着，遍历是用原数组遍历，还是用暂存容器遍历，需要考虑

- DFS：前序使用递归比较简单；非递归时，对于左右儿子没确定的节点，要用栈暂存
- BFS：对于左右儿子没确定的节点，用队列暂存

#### 判断

- 平衡：递归求树深度，是平衡返回深度，否则返回 -1
- 搜索：中序遍历结果为非降序
- 完全二叉树：层遍历看儿子节点
- 对称二叉树：中左右 与 中右左遍历结果一致
- 搜索二叉树的后序遍历：抓住后序最后一个节点是 root，找到它的左右子树对应的数组，再递归判断

#### 打印

- 按层：层遍历，加几个变量，记录层数、当前层剩余节点数和下一层节点数
- 之字型：层遍历，但是用两个栈（pushStack、popStack）实现整体 FIFO，局部 FILO

#### 其它

- 完全二叉树节点个数：通过深度判断左右子树是否满二叉树，若是则该子树节点个数可以直接用公式计算
- 累加和为定值的最长路径：DFS，需要带入递归的有：target、preSum、level、res，用的是和为定值最长子数组的思路，用 map 存累加和第一次出现的位置（注意：1.累加和为 0 的位置要确定；2.递归退出当前层的时候，判断当前层累加和是否在 map 中，若在则要退出去）
- 两个节点的公共祖先：1.将两个节点从树中剥离一个 DFS 链表出来；2.求这两个链表的交点
- 前缀树：每一个节点有 end 和 count 两个变量，作为大型字符串集索引的一种，用于查询/统计大数据中，某种前缀特征的字符串



### 栈

#### 栈的实现

- 数组实现栈：用 size 可以满足容量、push、pop
- 队列实现栈：两个队列 storage、help

#### 最值栈

- 除了栈本身，还要维护最值栈，在每次 push/pop 时，同步操作最值栈

#### 单调栈

栈底到栈顶满足单独递增（递减）规则，遇到相等的是继续压栈，还是弹栈或更新栈顶元素，需要看实际应用。

单调栈内存储信息看实际情况，不局限于元素大小、索引位置和出现次数等。它的特点是可以找到序列中离元素最近，比它大/小的元素

- 数组元素最近较大/小值：单调栈最直接的应用
- 数组直方图的最大长方形：单调栈的有趣应用
- 最大子矩阵：矩阵每一行都可以认为是一个数组直方图，进行相似操作
- 环形数组烽火对：1.组成烽火对 （a, b） 的有两种，一是 a < b，二是 a = b（不同烽火台，但是高度相等）；2.单调栈从最大值开始压栈，保证栈底上面所有元素两边都有比它大的值；3.单调栈存储的是元素索引位置，以及出现次数，对于非倒数第一、第二的两个元素，它们在出栈时的烽火对个数计算公式为：C(k, 2) + 2*k（其中 k 为元素重复出现次数）

#### 括号匹配

- 是否为合法的括号字符串：左括号压栈，右括号弹栈，如果弹栈时栈为空则不合法，遍历完后，栈不为空也不合法
- 最长匹配括号子字符串：一样左括号压栈，右括号弹栈，若成功弹栈，则需要记此时的匹配子串长度：右括号索引 - 栈顶元素索引，如果此时栈为空，则是右括号索引 - start，start 值在每次开启合法匹配的左括号压栈底时更新



### 堆

堆经常使用的是大根堆，小根堆，它们可以进行数据交换，PriorityQueue 默认是小根堆（升序比较器）

#### 实现

- 数组实现堆：上浮/下沉，上浮是只要儿子比父亲大，就一直往上找；下沉只要父亲比某个儿子小，就一直往下落。i 儿子父亲索引是 (i - 1) / 2，i 父亲的儿子索引分别是 2i + 1、2I + 2

#### 应用

- 数据流中位数：大根堆存较小的一半数，小根堆存较大的一半数，当 size 差超过 1 时，需要调整；取中位数时，只用关注两个堆顶即可
- K 次项目获利最多：贪心算法，每一次都需要找到当前可以做的收益最大的项目去做，将项目 node 以 cost 建小根堆，以 profit 建大根堆，不断将小根堆堆顶小于目前已有资金的项目移动到大根堆，直至不能移动时做大根堆项目



### 队列

#### 队列实现

- 数组实现：引入 offerIndex 和 pollIndex 执行对应操作，注意索引的循环使用
- 栈实现：两个栈 

#### 双端队列

双端队列使用 LInkedList，可以指定在队首/队尾进行 add/poll 操作，适用于做滑动窗口的最值管理

特点：

头部至尾部是单调的；取数从头部直接取最值；插入从尾部插入，插入前先 poll 掉违反插入后单调性的元素

一般存储索引值，通过索引是否在窗口内判断头部是否过期

- 滑动窗口最值：建立双端队列，在窗口滑动时，插入新数据，并去掉过期头部
- 最值差不大于 num 的子数组数量：p1, p2 双指针的窗口最值管理。满足条件的子数组内，所有子数组都满足；不满足条件的子数组被任何子数据包含时也都不满足；移动 p2 至不满足时，可以确定以 p1 为 起点的所有满足条件子数组，然后p1、p2都右移一步，继续寻找



### LRU

最近一段时间使用的放在头部，移除时从尾部开始

由一个 map 和一个 linkedList 实现，map 负责存储数据，linkedList  负责建立 key 的 LRU 关系（当 get/put 时，将相关 key 先 remove 再 addFirst，保证在头部），仅当 put 时元素数量超过了设置，并且 put 的 key 之前不存在时，才需要将末尾的 key 移除，并将其从 map 中也移除



## 算法思想

### 递归

#### 其它

- 岛问题-标记递归：第一次发现岛时，就将所有岛元素染色，避免后续重复登记