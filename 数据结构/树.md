## 树

### 目录

**二叉树的遍历:**

* [递归版](#递归版)
* [非递归版](#非递归版)
* [层遍历](#层遍历)
* [Morris遍历](#Morris遍历)

**二叉树的序列化和反序列化:**

* [前序反序列化-递归](#前序反序列化-递归)
* [层遍历反序列化](#层遍历反序列化)

**二叉树的判断:**

* [是否是平衡二叉树](#是否是平衡二叉树)
* [是否是搜索二叉树](#是否是搜索二叉树)
* [是否是完全二叉树](#是否是完全二叉树)
* [是否是对称二叉树](#是否是对称二叉树)
* [是否是搜索二叉树的后序遍历](#是否是搜索二叉树的后序遍历)

**二叉树的打印:**

* [按层多行打印二叉树](#按层多行打印二叉树)
* [之字形打印二叉树](#之字形打印二叉树)
* [打印和为定值的路径](#打印和为定值的路径)

**其它:**

* [求完全二叉树节点个数](#求完全二叉树节点个数)
* [数组大楼轮廓问题](#数组大楼轮廓问题)
* [利用前序中序重建二叉树](#利用前序中序重建二叉树)
* [寻找两个节点的最近公共祖先](#寻找两个节点的最近公共祖先)



----

### 递归版

[回到目录](#目录)

```java
public static void preOrder(Node head){
    if(head == null){
        return;
    }
    System.out.print(head.val + " ");
    preOrder(head.left);
    preOrder(head.right);
}

public static void midOrder(Node head){
    if(head == null){
        return;
    }    
    preOrder(head.left);
    System.out.print(head.val + " ");
    preOrder(head.right);
}

public static void lastOrder(Node head){
    if(head == null){
        return;
    }    
    preOrder(head.left);
    preOrder(head.right);
    System.out.print(head.val + " ");
}
```



### 非递归版

[回到目录](#目录)

非递归版不用系统压栈，需要自己在程序中决定什么时候压栈和弹栈

```java
public static void preOrder(Node head){
    if(head == null){
        return;
    }  
    
    Stcak<Node> stack = new Stack<>();
    stack.push(head);
    while(!stack.isEmpty()){
        Node cur = stack.pop();
        System.out.print(cur.val + " ");
        if(cur.right != null){ // 先存右孩子，但是取出来是先取左孩子
            stack.push(cur.right);
        }
        if(cur.left != null){
            stack.push(cur.left);
        }
    }
}

public static void midOrder(Node head){
    if(head == null){
        return;
    }
    
    Stcak<Node> stack = new Stack<>();
    while(!stack.isEmpty() || head!=null){           
        if(head == null){
            head = stack.pop();
            System.out.print(head.val + " ");
            head = head.right;
            continue;
        }
        if(head.left != null){
            stack.push(head);
            head = head.left;
        } else {        
            System.out.print(head.val + " ");        
            head = head.right;        
        }
    }
}

public static void lastOrder(Node head){
    if(head == null){
        return;
    }  
    
    Stcak<Node> stack = new Stack<>();
    Stcak<Node> help = new Stack<>(); // 前序改成中右左遍历进栈，再弹栈就变成了左右中
    stack.push(head);
    while(!stack.isEmpty()){
        Node cur = stack.pop();
        help.push(cur);
        if(cur.left != null){ 
            stack.push(cur.right);
        }
        if(cur.right != null){
            stack.push(cur.left);
        }
    }    
    while(!help.isEmpty()){ // 弹栈变成后序
        System.out.print(help.pop().val + " ");
    }
}
```



### 层遍历

[回到目录](#目录)

前面的遍历都是深度优先遍历，层遍历是广度优先遍历，即从上到下，从左到右，遍历每一层

```java
public static void layerOrder(Node head){
    if(head == null){
        return;
    }
    
    Queue<Node> queue = new LinkedList<>();
    queue.offer(head);
    while(!queue.isEmpty()){
        Node cur = queue.poll();
        System.out.print(cur.val + " "); 
        if(cur.left != null){ // 队列按遍历顺序存储
            queue.offer(cur.left);
        }
        if(cur.right != null){
            queue.offer(cur.right);
        }        
    }
}
```



### Morris遍历

[回到目录](#目录)

递归版是JVM压栈，非递归版是程序自己压栈，目的都是能多次来到某个节点，递归版一个节点会访问三次：中左中右中；非递归版一个节点会访问两次：中左中右。Morris遍历是利用每个节点左子树的最右节点存储当前节点，通过判断mostRight==null还是等于自己来判断是第一次还是第二次来到当前节点。

Morris遍历也是“中左中右”的访问顺序，它不用压栈，节省了空间复杂度，但是每次访问节点都要获取左子树最右节点，增多了时间，虽然时间复杂度还是O（N）。适用于对空间有极高要求的硬件情况。

```java
public static void morris(Node head){
    if(head == null){
        return;
    }
    
    while(head != null){
        if(head.left != null){ 
            Node mostRight = getMostRight(head);
            if(mostRight == null){ 
                // 第一次来到当前节点
                head = head.left;
            } else {
                // 第二次来到当前节点
                head = head.right;
            }

        } else { // 没有左子树，只会来到当前节点一次
            // 唯一一次来到当前节点
            head = head.right;
        }
    }
}
```



### 前序反序列化-递归

[回到目录](#目录)

```java
public static Node rebuildBT(String str){ // 假设是前序遍历的字符串
    if(str==null || str.length()==0){
        return null;
    }
    
    String[] strs = str.split("!");
    Queue<Node> queue = new LinkedList<>(); 
    for(int i=0; i<strs.length; i++){
        Node temp = strs[i]=="#" ? null : new Node(Integer.valueOf(strs[i]))
        queue.offer(temp);
    }
    return process(queue);
}

private static Node process(Queue<Node> queue){ // 递归版前序反序列化
    if(queue==null || queue.isEmpty()){
        return null;
    }    
    Node head = queue.poll();
    if(head != null){
        head.left = process(queue);
        head.right = process(queue);
    }
    return head;
}
```

前序反序列化-非递归的思路：前序序列的特点是每一个节点的下一个节点一定是它的左孩子,但是右孩子不确定.因此每从序列中取出一个节点,可以立马确定它的左孩子(但是不要取出来),因为它的右孩子不能立刻确定,所以它需要压栈.但是如果从序列中取出来的节点是null,说明它的上一个节点(栈顶)的左孩子是null,则上一个节点的右孩子一定是当前队列的第一个,此时弹栈并指定它的右孩子(但是不要取出来).
即根据序列特点,对序列中每一个节点进行逻辑判断,指定左右孩子关系.注意到指定左右孩子关系的时候,一定不能将其从序列中取出,因为它们也需要做同样的逻辑判断,去指定它们自己的左右孩子关系.



### 层遍历反序列化

[回到目录](#目录)

前序遍历反序列化时，因为左右节点可能是不相邻的，所以用队列存储所有节点，在递归求左子树时，就会将队列中用过的节点去掉；而层遍历反序列化时，由于左右孩子都是相邻的，所以用数组也可以。

```java
public static Node reconByLevelString(String str) { // 层遍历反序列化

    String[] values = str.split("!");
    int n = 0; 
    Node head = new Node(Integer.valueOf(values[n++]));
    Queue<Node> queue = new LinkedList<Node>(); // 队列记录重现了遍历的过程
    queue.offer(head);
    
    while(!queue.isEmpty()) {
        Node node = queue.poll();
        node.left = generateNodeByStr(values[n++]);
        if(node.left != null) {
            queue.offer(node.left);
        }
        node.right = generateNodeByStr(values[n++]);
        if(node.right != null) {
            queue.offer(node.right);
        }
    }
    return head;
}

private static Node generateNodeByStr(String str) {
    return str.equals("#") ? null : new Node(Integer.valueOf(str));
}
```



### 是否是平衡二叉树

[回到目录](#目录)

递归的方式去求二叉树的高度，如果是平衡的就返回正常高度，如果不是就返回-1

```java
public static int isBalanceTree(Node head){ // 返回-1不平衡，0是null，其他是平衡
    if(head == null){
        return 0;
    }
    
    int left = isBalanceTree(head.left);
    int right = isBalanceTree(head.right);
    if(left==-1 || right==-1 || Math.abs(left-right)>1){
        return -1;
    } else {
        return Math.max(left, right) + 1;
    }
}
```



### 是否是搜索二叉树

[回到目录](#目录)

A1：递归方式判断最简单

A2：可以将二叉树中序遍历，判断得到的数组是否是递增

```java
public static boolean isSearchTree(Node head){
    if(head == null){
        return true;
    }
    
    boolean flag =  head.left.val<head.val && head.val<head.right.val;
    return flag && isSearchTree(head.left) && isSearchTree(head.right);
}
```



### 是否是完全二叉树

[回到目录](#目录)

层遍历节点的过程中，如果某个基点的左孩子为null而有孩子非null，不是完全二叉树，如果左孩子为null或左右孩子都为null，则开启stage模式，后面所有遍历的节点，它的左右孩子都必须是null，否则也不是完全二叉树。

```java
public static boolean isAbsolutelyTree(Node head){
    if(head == null){
        return true;
    }
    
    Queue<Node> queue = new LinkedList<>();
    queue.offer(head);
    boolean flag = false;
    
    while(!queue.isEmpty()){
        Node cur = queue.poll();
        if(!flag){
            if(cur.left==null && cur.right!=null){
                return false;
            } else if(cur.left==null || cur.right==null) {
                flag = true;
            }
        } else {
            if(cur.left!=null || cur.right!=null){
                return false;
            } else {
                continue;
            }
        }
        if(cur.left != null){
            queue.offer(cur.left);
        }
        if(cur.left != null){
            queue.offer(cur.left);
        }        
    }
    
    return true;
}
```



### 是否是对称二叉树

[回到目录](#目录)

Q:如果一棵树它和它的镜像树(所有子树左右孩子互换)完全一样,则该树是对称树

```
判断依据:用前序(中左右)方式遍历一棵树和中右左方式遍历一棵树得到的顺序如果是完全一样的,即为对称树
```



### 是否是搜索二叉树的后序遍历

[回到目录](#目录)

Q:给定一个整数数组,数组中没有重复的元素,判断这个数组是否可以作为一颗搜索二叉树的后序遍历

```
一棵搜索二叉树的后序遍历数组,能提供的信息:数组中最后一个元素是头节点,从第一个比头节点大的元素开始,后面所有元素都是右子树的部分(除了头节点),前面所有元素都是左子树的部分.要求:
	左子树不为空时,所有元素都比头小(这个在找第一个右子树节点的时候已经判断了)
	右子树不为空时,所有元素都比头大
	以上,即判断了当前子树是搜索二叉树;然后递归判断左子树部分和右子树部分
```



### 按层多行打印二叉树

[回到目录](#目录)

Q:将二叉树按高度分行,打印成一行一行的格式

```
其实就是层遍历,但是层遍历的时候要区分现在打印的层是否打印完,下一次开启新一层打印(换行)
用两个变量cur和next分别记录当前行剩余的打印数和下一行需要的打印数
在打印当前层时,会把当前层的左右孩子(下一层)存入队列,每存一个,next就要++;每打印一次,cur就要--
当cur==0时,表明这一层打印完毕,需要换行;并将cur设为next,next归零重新开始下一层打印和下下一层的节点计数
```



### 之字形打印二叉树

[回到目录](#目录)

Q:在按层多行打印二叉树的基础上,要求每一层的打印顺序和上一层的打印顺序相反,即是之字形打印

![1552142052375](../img/%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.png)

```
因为按层打印时,打印下一层的顺序和上一层相反,比如打印3的时候,需要将6个7存入,如果用的是队列,无论先存6还是7,它们都会比4和5先打印,因为3在2前面打印.所以不能用队列,而是用栈存

stack1弹栈打印1时,存23入stack2(左右),stack2弹栈打印32时,存7654入stack1(右左),stack1弹栈打印4567时,存下面的数入stack2(左右)

规律:用两个stack存栈和弹栈,每一层打印完时,交换存栈和弹栈指向,并且每一层先存左孩子还是先存右孩子和上一层相反.这就需要cur和next来标志这一层是否打印完,flag来标志和上一层存左右孩子顺序相反以及stack1和stack2弹栈压栈角色互换
```

```java
public static void printBTOrderedByZig(Node head) {

    if(head == null) {
        System.out.println("head is null.");
        return;
    }

    Stack<Node> popStack = new Stack<Node>();
    Stack<Node> pushStack = new Stack<Node>();
    popStack.push(head);

    boolean flag = true; // 决定每层保存孩子的入栈顺序是左右还是右左
    int cur = 1;
    int next = 0;
    while(!popStack.isEmpty() || !pushStack.isEmpty()) {

        Node curNode = popStack.pop();
        System.out.print(curNode.value + " ");
        if(flag) {
            if(curNode.left != null) {
                pushStack.push(curNode.left);
                next++;
            }
            if(curNode.right != null) {
                pushStack.push(curNode.right);
                next++;
            }
        } else {
            if(curNode.right != null) {
                pushStack.push(curNode.right);
                next++;
            }
            if(curNode.left != null) {
                pushStack.push(curNode.left);
                next++;
            }
        }
        cur--;
        if(cur == 0) { // 到下一层时应该做的工作
            System.out.println(); // 换行
            cur = next;
            next = 0;
            flag = !flag;
            Stack<Node> temp = popStack;
            popStack = pushStack;
            pushStack = temp;
        }
    }
}
```



### 打印和为定值的路径

[回到目录](#目录)

Q:打印和为定值的路径,路径:根节点到叶节点所经过的所有节点

```
其实就是遍历的过程,只是在遍历到叶节点时,需要验证是否和为定值,所以需要一个stack存储当前路径,当离开这个节点时,stack弹出这个节点.
即stack实时更新当前路径,当记录到叶节点时,统计路径和.决定是否打印
```



### 求完全二叉树节点个数

[回到目录](#目录)

Q：给定一个完全二叉树head，求其节点个数

A：一个树节点个数 = 左子树节点个数 + 1 + 右子树节点个数。首先求当前节点左子树的高度，然后求当前节点右子树的高度，如果右子树高度等于左子树高度，表明左子树是一颗满二叉树，它的节点个数可以直接通过高度计算出来；如果右子树高度小于左子树高度，表明右子树是一颗满二叉树，它的节点个数也可以通过高度计算出来。因此每次只用遍历一个节点即可，并且求完全二叉树所有子树高度只用看这个树子的“左臂”长度

```java
public static int getAbsoluteTreeNodes(Node head){
    if(head == null){
        return 0;
    }
    
    int left = getAbsoluteTreeHeight(head.left);
    int right = getAbsoluteTreeHeight(head.right);
    if(right < left){ // 右子树是满二叉树
        return getFullTreeNodes(right) + getAbsoluteTreeNodes(head.left) + 1;
    } else { // 左子树是满二叉树
        return getFullTreeNodes(left) + getAbsoluteTreeNodes(head.right) + 1;
    }
}

private static int getAbsoluteTreeHeight(Node head){
    if(head == null){
        reutn 0;
    }
    
    int res = 0;
    while(head != null){
        head = head.left;
        res++;
    }
    return res;
}

private static int getFullTreeNodes(int height){
    return Math.pow(2, height) - 1; // 等比数列求和公式
}
```



### 数组大楼轮廓问题

[回到目录](#目录)

Q：一个n行3列的二维数组,每行的三列分别表示一幢楼的开始和终止位置,以及高度,楼的位置都在x轴上.求给定二维数组输出的楼栋轮廓线。如图，大楼对应的二维数组为{{1,3,3},{2,4,4},{5,6,1}},输出轮廓为{{1,2,3},{2,4,4},{5,6,1}}

A：

![1555668551319](../img/数组大楼轮廓.png)

```java
public static TreeMap<Integer, Integer> getOutline(int[][] arr){
    if(arr == null || arr[0] == null || arr[0].length == 0) {
        return null;
    }

    int row = arr.length;
    BuildingPair[] buildings = new BuildingPair[2*row];
    for(int i = 0; i < row; i++) {
        buildings[2*i] = new BuildingPair(arr[i][0], arr[i][2], true);
        buildings[2*i + 1] = new BuildingPair(arr[i][1], arr[i][2], false);

    }
    Arrays.sort(buildings, new BuildingPairComparator()); // 按横坐标排序

    TreeMap<Integer, Integer> heightMap = new TreeMap<Integer,Integer>(); // 高度map
    TreeMap<Integer, Integer> outlineMap = new TreeMap<Integer,Integer>();//轮廓点map

    for(int i = 0; i < buildings.length; i++) {
        int height = buildings[i].height;
        if(heightMap.size() != 0) { // 高度树里面有元素
            int lastMaxHeigt = heightMap.lastKey(); // 当前最大的高度

            // 存进heightmap观察最大高度是否变化
            if(buildings[i].isUp) { // 上升
                heightMap.put(height, heightMap.containsKey(height) ? heightMap.get(height)+1 : 1);
            } else if(heightMap.get(height) == 1){
                heightMap.remove(height);
            } else {
                heightMap.put(height, heightMap.get(height)-1);
            }

            int newMaxHeight = heightMap.size() != 0 ? heightMap.lastKey() : 0; // 目前最大的高度
            if(newMaxHeight != lastMaxHeigt) { // 高度变化,是轮廓的节点,需要存储
                outlineMap.put(buildings[i].x, newMaxHeight);
            }
        } else {
            heightMap.put(height, 1);
            outlineMap.put(buildings[i].x, height);
        }
    }

    return getOutline(outlineMap);
}

// 辅助类:两个BuildingPair对象表示一幢楼的起落
public static class BuildingPair{
    int x;
    int height;
    boolean isUp;

    public BuildingPair(int x, int height, boolean isUp) {
        super();
        this.x = x;
        this.height = height;
        this.isUp = isUp;
    }
}

// 楼比较器,根据位置
public static class BuildingPairComparator implements Comparator<BuildingPair>{

    @Override
    public int compare(BuildingPair o1, BuildingPair o2) {
        if(o1.x != o2.x) {
            return o1.x - o2.x;
        }
        if(o1.isUp != o2.isUp) { // 先落再升
            return o1.isUp ? -1 : 1;
        }
        return 0;
    }

}

public static int[][] getOutline(TreeMap<Integer,Integer> treeMap){ // 重载

    if(treeMap == null) {
        return null;
    }

    int size = treeMap.size();
    int[][] res = new int[size-1][3];
    int index = 0;
    while(!treeMap.isEmpty()) {
        Entry<Integer, Integer> firstEntry = treeMap.pollFirstEntry(); // 当前最左的拐点
        if(index < res.length) {
            res[index][0] = firstEntry.getKey(); // 开始位置
            res[index][2] = firstEntry.getValue(); // 高度
        }

        if(index > 0) {
            res[index-1][1] = firstEntry.getKey(); // 开始位置等于上一个区间的结束位置
        }

        index++;
    }
    return res;
}
```



### 利用前序中序重建二叉树

[回到目录](#目录)

Q:已知BT的前序遍历序列和中序遍历序列,重建这个二叉树(不含有重复数字)

```
序列中不含有null的标记,所以一个序列不能还原整个二叉树
前序第一个节点是头节点,找到中序序列这个头节点.左边是左子树中序序列,右边是右子树中序序列
递归的去求左子树和右子树即可(提供对应的前序和中序)
```



### 寻找两个节点的最近公共祖先

[回到目录](#目录)

Q:给一个树的头节点,和两个节点,寻找这两个节点的最近公共祖先(可能有节点不在树中.节点只有left和right)

```
首先寻找这两个节点在树中的路径,并将路径用栈存储(只有栈才能顺序存储路径).然后将栈中元素弹出,就成了求两个链表的公共节点问题,可以用Set辅助空间,也可以用链表来解决.
```

