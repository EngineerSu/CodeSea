## 字符串

### 目录

* [打印九宫格数字匹配的所有字符串](#打印九宫格数字匹配的所有字符串)
* [最长不重复的子字符串](#最长不重复的子字符串)
* [左旋(翻转)字符串](#左旋(翻转)字符串)
* [判断一个字符串是不是数字](#判断一个字符串是不是数字)



### 打印九宫格数字匹配的所有字符串

[回到目录](#目录)

Q:给定一个字符串str,每个字符范围是'2'~'9',打印整个字符串所有可能匹配的字母组合

Example:

```
Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

![1554519537828](../img/九宫格数字按键.png)

```
题目本身很简单,就是考察递归的写法.每个字符数字有3或4个选择的字母可以匹配,每个字符第一个可以匹配的字母由offset决定.(8对应了4个字母)
```

```java
class Solution {
    public List<String> letterCombinations(String digits) {
        
        List<String> list = new ArrayList<>();
        if(digits == null || digits.length() == 0){
            return list;
        }
        
        char[] charArr = new char[digits.length()];        
        process(0, charArr, digits, list);
        
        return list;
    }
    
    public static void process(int p, char[] charArr, String str, List<String> list){
        if(p == str.length()){
            list.add(new String(charArr));
            return;
        }
        
        int offset = str.charAt(p) >= '8' ? 1 : 0;
        int n = str.charAt(p) == '7' || str.charAt(p) == '9' ? 4 : 3;
        
        for(int i = 0; i < n; i++){
            charArr[p] = (char)((str.charAt(p)-'2')*3 + 'a' + i + offset);
            process(p+1, charArr, str, list);
        }      
    }
}
```



### 最长不重复的子字符串

[回到目录](#目录)

Q:Given a string, find the length of the **longest substring**without repeating characters.

```
Example:
Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3
```

```
思路:初始化p1,p2两个指针在0位置,p2指针不断++,并且每次将它的字符和位置作为一个<k,v>对,存进map,p1则在目前的位置和map.get(str.charAt(p2))中取最大值,这样避免了对p2字符出现位置的讨论,直接一次遍历,即可求解.
```

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s == null || s.length() == 0){
            return 0;
        }     
        HashMap<Character,Integer> map = new HashMap<Character,Integer>();
        int p1 = 0;
        int p2 = 1;
        int max = 1;
        map.put(s.charAt(0),0);
        while(p2 < s.length()){
            p1 = Math.max(p1, map.get(s.charAt(p2))==null ? p1 : map.get(s.charAt(p2))+1); // 考虑一下空指针异常的问题
            map.put(s.charAt(p2),p2);
            max = Math.max(max, p2-p1+1);
            p2++;
        }
        return max;
    }
}
```



### 左旋(翻转)字符串

[回到目录](#目录)

Q:左旋操作是指将字符串前n位移动到字符串的后面,如将字符串abcdefg翻转成cdefgab

```
定义一个函数翻转字符串,用p1指向字符串的开头,p2指向字符串的结尾,每次将p1和p2指向的字符交换位置,直到p1右移和p2重合或者超过了p2.
这样的翻转是将整个字符串的前后位置和顺序全部翻转了.如果再对字符串执行一次这个函数,字符串又变回原样

因此观察ab和cdefg是位置前后变了,因此可以将其做两部分,第一次对整个字符串翻转(调位置),第二次单独翻转字符串的两个部分(调顺序)
```



### 判断一个字符串是不是数字

[回到目录](#目录)

```
只涉及到简单的业务逻辑:用p指针表示正在查看的字符位置,如果第一个是"+"或"-",跳到下一个,接下来判断是不是整数(不能为空),直到遇到"."(小数) 或e/E(科学计数法)
	.后面的所有字符必须是整数(不能为空)
	e/E后面的第一个字符可以是"+"或"-",后面的字符也必须是整数(不能为空)
```

