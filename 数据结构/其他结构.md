## 其他结构

### 并查集：越查越简单

并查集结构:头节点指向自己,其他节点有一个parent节点.对一个节点A不停找parent节点,直到parent节点就等于自己,这个节点是A的头节点.拥有相同头节点的节点是属于同一个集合.

合并规则:比较两个头节点挂的节点个数多少,将child节点个数少的头节点挂在多的头节点上,完成了集合的合并.

查询优化:每次查询后,都会将查询路径上所有节点都直接挂在头节点下，查询优化的存在使得"越查越简单".可以认为当查询和合并这两个操作量级逼近O(N)时,它们的平均时间复杂度只有O(1)

并查集类：并查集的类并不是一个集合,而是一个容器,其中提供两个hashmap成员变量,<Node,Node>和<Node,Integer>。用来存储每个节点的父节点,以及集合(key是它的头节点)中含有的节点个数。并查集类会提供makeSets，unionSets，isSameSet方法，makeSets方法是初始化的过程，将所有节点初始化为若干个集合，然后根据需要进行unionSets和isSameSet方法。

#### 岛问题

![1551191648762](../img/岛问题.png)

A：遍历这个矩阵，遇到1就开启感染模式，将这个1所在同一个“岛”的1都变成2，那么后续遍历时就不会重复计算

```java
public static int getIsland(int[][] arr) {
    if(arr == null || arr[0] == null) {
        return 0;
    }

    int row = arr.length;
    int column = arr[0].length;
    int res = 0;

    for(int i = 0; i < row; i++) {
        for(int j = 0; j < column; j++) {
            if(arr[i][j] == 1) {
                infect(arr, i, j, row, column);
                res++;
            }
        }
    }
    return res;
}

// 感染函数
private static void infect(int[][] arr, int i, int j, int row, int column) {
    if(i < 0 || i == row || j < 0 || j == column || arr[i][j] != 1 ) {
        return;
    }

    arr[i][j] = 2;
    infect(arr, i-1, j, row, column);
    infect(arr, i+1, j, row, column);
    infect(arr, i, j-1, row, column);
    infect(arr, i, j+1, row, column);
}
```

##### 岛问题的分布式计算

当给的矩阵数据很大时,需要将矩阵进行分割做分布式计算,分布式计算内部还是采用感染函数的方式,但是需要处理不同分割矩阵的边界:即一个岛可能在两个分割矩阵里都算过了,这个时候需要采用并查集的结构.

首先将一个矩阵做成一个并查集(初始状态是各自成一个集合),当发现1,一样执行感染函数,不过这个时候不是将1改为2,而是将上下左右的1都和触发感染函数的1所在集合合并.这样同一个岛的1就都在一个集合里.

处理边界:如果两边都是1,而且不在同一个集合中,表明存在重复算,岛的数量-1,两个集合合并.如果两边都是1,发现确实也在一个合并的集合中,则跳过.如果两边不都是1,跳过.

就这样用并查集的 查 和 并,解决了边界"去重"的问题.

![1551192123821](../img/岛问题分布计算-并查集方法.png)

### 前缀树

前缀树结构：节点路径上存储的是字符串的字符，节点本身存储一些其他信息：有多少次经过这个节点，有多少次以这个节点为字符串的结尾字符。一个节点可以分成多叉的节点路径，是通过HashMap来体现的。

前缀树意义：当要查询/统计大字符串集合中,前缀拥有某些特点的字符串时使用很方便.使用时将这些字符串构成一颗前缀树,然后即可查询各种不同的统计效果

增加:从Root节点出发,根据字符串的每一位作为key查询当且节点的map中的value是不是null,如果不是表明当前字符出现过,将这个value对应的Node相关参数更新一下(经过的次数,结尾的次数);如果是null,就创建一个新的Node,和当前字符作为键值对put进当前节点的map,更新node参数.然后继续以Node为新的当前节点,重复上述操作:...
构造:字符串集合都做一次增加
删除:沿途将经过次数和最后一次结尾次数减1,如果发现某个经过次数/结尾次数是1,那么删除这个<k,v>对,后面就不用操作了

![1555676810107](../img/前缀树结构.png)

```java
public class PreStrTree {
	
	// 字符串的前缀树
	
	// 前缀树的Node
	public static class PreNode{
		
		public int end = 0; // 存储以上条路径字符结尾的个数  ==  以节点前面的路为终点,被走过几次
		public int count = 0; // 存储经过上条路径字符的个数  == 节点前面相邻的路被走过几次
		public HashMap<Character, PreNode> path = new HashMap<Character, PreStrTree.PreNode>(); // 即用路径来存储字符串,通过key搜索到的value不为空,表明这条路径上的字符是存在的
		
	}
	
	public PreNode root;
	
	public PreStrTree() {
		root = new PreNode();
	}
	
	// 树上增加一系列字符串
	public void createTree(List<String> source) {
		
		if(source == null) {
			return;
		}
		
		for(String each:source) {
			insert(each);
		}
	}
	
	// 树上增加一个字符串
	public void insert(String str) {
		if(str == null || str.length() == 0) {
			return;
		}
		
		PreNode pre = root;
		char each;
		PreNode cur;
		int l = str.length();
		for(int i = 0; i < l; i++) {
			each = str.charAt(i);
			cur = pre.path.get(each);
			if(cur == null) {
				cur = new PreNode();
				pre.path.put(each, cur);
			}
			cur.count++;
			pre = cur;
		}
		pre.end++;
	}
	
	// 树上删除字符串
	public boolean delete(String str) {
		if(str == null || str.length() == 0	) {
			return false;
		}
		
		char each;
		int l = str.length();
		PreNode pre = root;
		PreNode cur;
		for(int i = 0; i < l; i++) {
			
			each = str.charAt(i);
			cur = pre.path.get(each);
			if(cur == null) {
				return false; // 没有当前字符串
			} else {
				if(cur.count == 1) {
					pre.path.put(each, null);
					return true;
				} else {
					cur.count--;
					if( i == l-1) {
						cur.end--;
					} else {
						pre = cur;
					}
				}
			}
		}
		
		return true;
	}
	
	// 查询字符串在这颗树上出现几次
	public int search(String str) {
		
		if(str == null || str.length() == 0	) {
			return 0;
		}
		
		char each;
		int l = str.length();
		PreNode pre = root;
		PreNode cur = pre;
		for(int i = 0; i < l; i++) {
			
			each = str.charAt(i);
			cur = pre.path.get(each);
			if(cur == null) {
				return 0;
			} else {
				pre = cur;
			}
		}
		
		return cur.end;
	}
	
	// 查询特定前缀字符串的出现次数
	public int prefixNumber(String str) {
		
		if(str == null || str.length() == 0	) {
			return 0;
		}
		
		char each;
		int l = str.length();
		PreNode pre = root;
		PreNode cur = pre;
		for(int i = 0; i < l; i++) {
			
			each = str.charAt(i);
			cur = pre.path.get(each);
			if(cur == null) {
				return 0;
			} else {
				pre = cur;
			}
		}
		
		return cur.count;
	}
}
```

### LRU的简单实现

![1557231797958](../img/LRU的双向链表实现.png)

![1557231839273](../img/LFU的双向链表实现.png)

LRU：插入元素时，如果元素不存在则插到链表头部，如果存在，则将该元素调至链表头部，该元素之前的所有元素往后挪一位。如果链表满了，插入一个不存在的元素，会使链表尾部元素从缓存中剔除。

LFU：插入元素时，如果元素不存在，则插入链表尾部，并初始化其出现次数为1，如果插入前链表是满的，那么原链表尾部的元素会被剔除；如果元素存在，则它的出现次数+1，并根据出现次数调整它在链表中的位置。