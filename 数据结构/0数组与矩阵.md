## 数组与矩阵

### 目录

**打印问题**:

* [转圈打印矩阵](#转圈打印矩阵)
* [旋转正方形矩阵](#旋转正方形矩阵)
* [之字形打印矩阵](#之字形打印矩阵)

**搜索问题:**

* [某数是否在行列有序的矩阵中](#某数是否在行列有序的矩阵中)

**其它:**

* [找出数组中出现超过一半的数](#找出数组中出现超过一半的数)
* [连续子数组的最大和](#连续子数组的最大和)
* [数组中重复的数字](#数组中重复的数字)
* [数组全排列的下一个排列](#数组全排列的下一个排列)
* [一组整数对能构成的最长递增链](#一组整数对能构成的最长递增链)



-----

### 转圈打印矩阵

[数组与矩阵目录](#目录)

Q:给一个矩阵(二维数组),要求顺时针从外到内转圈打印这个矩阵

A:顺时针打印一个"口"字型只用知道它的左上,右下坐标即可.转圈打印就相当于从外到内,若干个"口"子边框的打印,对于一行或一列要单独列出打印情况.

```java
package datastrutcture.array;

public class ClockWisePrintMatrix {

    // Q: 给一个矩阵(二维数组),顺时针打印它
    // A: 首先打印矩阵的最外层矩形边框,再打印次外层,依次类推,即是按要求打印. 打印一个矩形边框的方法是可以重用的

    public void clockwisePrintMatrix(int[][] matrix) {
        if (null == matrix || 0 == matrix.length || null == matrix[0] || 0 == matrix[0].length) {
            return;
        }
        int row = matrix.length;
        int col = matrix[0].length;
        clockwisePrintBorder(matrix, 0, 0, --row, --col);
    }

    private void clockwisePrintBorder(int[][] border, int leftUpX, int leftUpY, int maxRight, int maxDown) {
        // 打印完毕的条件
        if (leftUpX > maxRight || leftUpY > maxDown) {
            return;
        }

        // 考虑一横或一竖的特殊情况
        if (leftUpY == maxDown) {
            while (leftUpX <= maxRight) {
                System.out.println(border[leftUpX++][leftUpY] + " ");
            }
            return;
        }
        if (leftUpX == maxRight) {
            while (leftUpY <= maxDown) {
                System.out.println(border[leftUpX][leftUpY++] + " ");
            }
            return;
        }

        // 一般情况:打印矩形边框
        int curX = leftUpX;
        int curY = leftUpY;
        while (curY < maxRight) {
            System.out.println(border[curX][curY++] + " ");
        }
        while (curX < maxDown) {
            System.out.println(border[curX++][curY] + " ");
        }
        while (curX > leftUpX && curY > leftUpY) {
            System.out.println(border[curX][curY--] + " ");
        }
        while (curX > leftUpX) {
            System.out.println(border[curX--][curY] + " ");
        }

        // 继续打印内层矩形边框
        clockwisePrintBorder(border, ++leftUpX, ++leftUpY, --maxRight, --maxDown);
    }
}
```



### 旋转正方形矩阵

[数组与矩阵目录](#目录)

Q:给一个方阵(二维数组arr),将其顺时针旋转90°

A:从外边框ABCD考虑,顺时针旋转90°首先是4个端点交换位置:A->B,B->C,C->D,D->A. 然后将A,B,C,D四个点分别在其边上往前走一步,再进行这样的步骤即可.  因此分别将各个边框这样交换即可

```java
public static void printByROtatingOrder(int[] arr){
    if(arr == null || arr.length == 0 || arr[0] == null || arr[0].length == 0){
        return;
    }
    
    int row = arr.length;
    int col = arr[0].length;
    process(arr, 0, 0, row-1, col-1);    
}

public static void process(int[][] arr, int LUX, int LUY, int RDX, int RDY){
    if(LUX > RDX || LUY > RDY){
        return;
    }
    
    int i = 0;
    while(LUY + i < RDY){
        int temp = arr[LUX, LUY+i];
        arr[LUX, LUY+i] = arr[RDX-i][LUY]; // D->A
        arr[RDX-i][LUY] = arr[RDX][RDY-i]; // C->D
        arr[RDX][RDY-i] = arr[LUX+i][RDY]; // B->C
        arr[LUX+i][RDY] = temp; // A->B
		i++;
    }
    
    process(arr, LUX+1, LUY+1, RDX-1, RDY-1);
}
```



### 之字形打印矩阵

[数组与矩阵目录](#目录)

Q:给定一个矩阵(二维数组arr),从矩阵的左上角开始,之字形绕着打印

A:用两个辅助点,去标记之字形的两个端点.由于之字形特点,打印顺序注意每次要调换

```java
public static void printByZigOrder(int[][] arr){
    if(arr == null || arr.length == 0 || arr[0] == null || arr[0].length == 0){
        return;
    }
    
    int row = arr.length;
    int col = arr[0].length;
    int p1X = 0, p1Y = 0, p2X = 0, p2Y = 0;
    boolean flag = true;
    while(p1X < row){
        print(arr, p1X, p1Y, p2X, p2Y, flag);
        flag = !flag;
        if(p1Y == col-1){
            p1X++;
        } else {
            p1Y++;
        }  
        if(p2X == row-1){
            p2Y++;
        } else {
            p2X++;
        }        
    }    
}

public static void print(int[][] arr, int p1X, int p1Y, int p2X, int p2Y, boolean flag){
    if(flag){ // p1 -> p2
        while(p1Y >= p2Y){
            System.out.print(arr[p1X++][p1Y--]);
        }
    } else { // p2 -> p1
        while(p2Y <= p2Y){
            System.out.print(arr[p2X--][p2Y++]);
        }        
    }
}
```



### 某数是否在行列有序的矩阵中

[数组与矩阵目录](#目录)

Q:给一个矩阵arr和一个数num,arr每行每列都是升序,试判断num是在num中

A:利用有序性搜索.首先将num与右上角对比,如果比右上角大,则往下搜索;反之往左搜索.因此这样搜索只能往左走或往下走,时间复杂度是O(M+N)

```java
public static boolean hasNum(int[][] arr, int num){
    if(arr == null || arr.length == 0 || arr[0] == null || arr[0].length == 0){
        return false;
    }    
    
    int x = 0;
    int y = arr[0].length-1;
    
    while(x < arr.length && y > -1){
        if(arr[x][y] > num){
            y--;
        } else if(arr[x][y] < num) {
            x++;
        } else {
            return true;
        }
    }
    
    return false;
}
```



### 找出数组中出现超过一半的数

[数组与矩阵目录](#目录)

Q: 给定一个数组,假定这个数组中某个数的出现次数超过了数组长度的一半,找出这个数

A: 用num和count两个int变量, 遍历数组即可实现. 代码如下, 思想是超过一半数抵消剩下的数, count还有多余

```java
public int findOverHalfNum(int[] arr) {
    int count = 0;
    int num;
    for (int i = 0; i < arr.length; i++) {
        if (count == 0) {
            num = arr[i];
        } else {
            count = num == arr[i] ? count + 1 : count - 1;
        }
    }
    return num;
}
```



### 连续子数组的最大和

[数组与矩阵目录](#目录)

Q: 给一个数组,有正有负,求连续子数组的最大和

A: 用curSum和遍历的数进行相加, 若加到某个位置时curSum<0, 则将curSum置零(相当于舍弃前面的累加, 重新累加), 只要curSum>0, 则将其与最大值max进行比较即可.

```java
public int findMaxSequenceSum(int[] arr) {
    int max = 0;
    int curSum = 0;
    for (int i = 0; i < arr.length; i++) {
        curSum += arr[i];
        if (curSum < 0) {
            curSum = 0;
        } else {
            max = Math.max(max, curSum);
        }
    }
    return max;
}
```



### 数组中重复的数字

[数组与矩阵目录](#目录)

Q: 已知数组(长度为n)中的元素大小范围是0~n-1,求找出这个数组中任意一个重复的数字.

A1: 遍历数组, 遇到arr[i]时, 试图将arr[i]与索引为arr[i]的位置交换, 交换前检查`arr[arr[i]] == arr[i]`是否成立, 若成立, 表明找到重复数字, 不成立则交换位置. 继续遍历

A2: 用HashSet. A2简单, 空间复杂度为O(N), 但是没有改变原数组. A1空间复杂度为O(1), 但是改变了原数组.

```java
public Integer findDuplicatedNumInArray(int[] arr) {
    if(null == arr || 0 == arr.length) {
        return null;
    }
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == i) {
            continue;
        } else if (arr[arr[i]] == arr[i]) {
            // 交换之前发现"坑已经被占了"
            return arr[i];
        } else {
            // 交换i和arr[i]两处的元素
            swap(arr, arr[i], i); 
        }
    }
    return null;
}
```



### 数组全排列的下一个排列

[数组与矩阵目录](#目录)

Q:给定一个int数组nums(元素范围0~9),求这个数组的全排列中,比它"数组值"大的下一个排列,将数组变成下一个排列. ("数组值"指的是将数组中所有的数看作一个整数的各个位,这个整数的值即"数组值")

![1563541384146](img/0数组与矩阵/1563541384146.png)

解释一下上面的步骤: 如果希望重新排列组合这些数, 找到一个比当前数大的最小组合, 那么第一步就是判断首先要增大哪一位? 这个位显然越低越好, 那么为什么增大第5位数? 因为1~4位已经形成了最大排列, 如果不增大第5位, 再往低位找, 不能通过增大1~4位中任何一位使组合数变的更大. 所以从末尾往前看, 第一个打破递增单调性的位就是需要增大的最低位. 

因为希望这个组合最小, 所以当然是从1~4位中寻找最小的位与第5位交换.

交换之后, 要想组合最小, 当然是把剩下的数顺序排列.

```java
class Solution {
    public void nextPermutation(int[] nums) {
        if(nums == null || nums.length < 2){
            return;
        }
        
        int index = nums.length - 1;
        while(index-1 >= 0 && nums[index-1] >= nums[index]){
            index--;
        }
        int start = index;
        if(start != 0){ // 如果整个数组都是倒序排列,就不用交换位置了
            index = nums.length-1;
            while(nums[start-1] >= nums[index]){
                index--;
            }
            swap(nums, start-1, index);
        }
        
        index = nums.length - 1;
        
        while(start < index){
            swap(nums, start++, index--);
        }
    }
    
    public static void swap(int[] nums, int i, int j){
        nums[i] = nums[i] ^ nums[j];
        nums[j] = nums[i] ^ nums[j];
        nums[i] = nums[i] ^ nums[j];
    }
}
```



### 一组整数对能构成的最长递增链

[数组与矩阵目录](#目录)

[646. Maximum Length of Pair Chain(Medium)](https://leetcode.com/problems/maximum-length-of-pair-chain/description/)

Q: 给一个二维数组pairs, 数组中每行是一对整数, 且`pairs[i][0] < pairs[i][1]`, 如果`pairs[i][1] < pairs[j][0]`, 那么第j行就可以接在第i行后成为一个递增链, 求最长的递增链长度.

```
Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4]
```

A: 首先对二维数组进行排序, 排序的依据是根据二维数组的第二列从小到大排序, 那么从第一行作为最长的递增链头开始, 后面只用遍历行, 找到某一行的第一列比当前递增链的链尾大, 则更新链尾, 并且递增链长度+1.

S: 这里用正则表达式代替了Comparable的子类对象, 简化了代码.

````java
class Solution {
    public int findLongestChain(int[][] pairs) {
        if (pairs == null || pairs.length == 0) return 0;
        // 正则表达式表示的比较器
        Arrays.sort(pairs, (a, b) -> (a[1] - b[1])); 
        int curRight = pairs[0][1];
        int res = 1;
        int i = 1;
        while(i < pairs.length){
            if(pairs[i][0] > curRight){
                res++;
                curRight = pairs[i][1];
            }
            i++;
        }
        return res;
    }
}
````



