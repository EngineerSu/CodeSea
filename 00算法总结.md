## 0代码指南

### 常用代码

- N皇后

    ```java
    public static int nQueen(int n) {
        if (n < 2) {
            return n;
        }
        return nQueen(0, 0, 0, 0, n);
    }
    private static int nQueen(int row, int col, int pie, int na, int n) {
        if (row == n) {
            // 走完了n行,表示一种可行方法
            return 1;
        }
        int cnt = 0;
        // p二进制位中为1的位置表示目前行可以放置皇后的列位置
        // 因为int数有32位,所以要去掉高位中无用的1,只取最低的n位
        int p = (~(col | pie | na)) & ((1 << n) - 1);
        // 只要p中1没有"消耗"完,表示可以继续尝试
        while (p > 0) {
            // curCol表示取出p中最右的1位置,用它去模拟放置皇后
            int curCol = p & (-p);
            // 模拟curCol位置放置皇后
            cnt += nQueen(row + 1, col | curCol, (pie | curCol) << 1, (na | curCol) >> 1, n);
            // 去掉p中最右侧的1(因为上面已经模拟放过了)
            p &= p-1;
        }
        return cnt;
    }
    ```

    

### 技巧

- 当特殊情况比较复杂时，并且它的结果可能后面要用时，用一个方法单独去求特殊情况，便于复用
- list可以作为构造方法参数去new一个新的list，相当于拷贝

### 易错

- 使用`Integer.parseInt(str)`时需要考虑str会不会造成int溢出。解决办法是使用`Long.parseLong(str)`，或对于超长字符串写一个字符串的加法

## 1数据结构

### 0数组

- **打印矩阵**：打印路径可循环，找到位置指针指导打印路径

- **O(1)找数组出现超过一半的数**

- **O(1)找数组(1~n)中任一个重复的数字**

- **子数组最大和**：当前和sum若小于0，则sum从当前位置重新开始，否则继续累加

- **和为定值的最长子数组**：记录0~i的所有累加和sum[i]，则找sum[j] = target - sum[i]，表明j~i的累加和是target，j应该是`target - sum[i]`出现的最早位置

    子问题有：奇偶个数相同的最长子数组，0与1个数相同的最长子数组。总之核心是**最长子数组**

- **全排列值的下一个递增排列**：弄清楚全排列值递增的规则

- **整数对的最长递增链**：二维数组排序的lambda表达式` Arrays.sort(pairs,(a, b) -> (a[1] - b[1]));`



### 1字符串

- **翻转字符串**：先整体翻转，再各部分翻转



### 2哈希表

- **拷贝有random指针的链表**：map存储了旧新节点对应关系，以旧找新
- **getRandom的Set实现**：两个map，一个存位置元素对应关系，一个存元素位置对应关系，删除元素时，将最后一位元素移动到被删除的序号位置，保证位置序号一直是连续的
- **单词替换字母形成新单词**：单词少任一个字母，可以得到很多key，都和该单词组成键值对存储，处理完所有单词问题就ok了



### 3链表

- **翻转链表**：每次都只修改cur和pre的指向关系，next的存在是为了备份下一个循环节点
- **找链表中点**：slow在0位置，fast在1位置，开始走，直到fast或fast.next是空，slow停在了中点位置(偶数个靠左)
- **判断链表回文**：栈 或 找到中点翻转右边链表再比较，最后要还原
- **判断链表有环**：slow在0位置，fast在1位置，直到相遇就有环，fast停下，slow继续走到再次相遇的步数就是环长，此时fast/slow都回0位置，速度一样，让fast先走环长，再一起走再次相遇在入环节点
- **判断链表相交**：无环和无环相交 / 有环和有环相交
- **链表排序**：排序的大体思想和数组一样，但是具体技巧不同
    - 插排：创建一个新链表存放已经遍历过的有序部分，后面遍历的每个元素都插排到新链表中
    - partition：需要smallHead/smallTail equalHead/equalTail bigHead/bigTail六个辅助节点
    - merge：需要newHead/newTail两个辅助节点



### 4树

- **二叉树非递归遍历**
    - 前序-中左右：先压栈头节点，只要栈不是空，就弹出一个元素并打印(输出到遍历结果中)，然后判断右孩子非null压栈，左孩子非null压栈
    - 中序-左中右：头节点非null或栈不为空都可以进循环体，如果头节点是null表明上一次(右滑)的右孩子是null，此时弹栈一个节点打印，并右滑；如果头节点非null则判断它左孩子是否也非null，左孩子非null则当前节点压栈，直到左孩子是null，则打印当前节点并右滑
    - 后序-左右中：相当于中右左的倒序，所以改造一下前序，再把结果倒一下即可
    - 层遍历：头节点入列，只要队列不是空，每次出列一个节点并打印，然后判断左右孩子是否非null，非null则入列
    - Morris遍历：用左子树的最右节点指向当前节点，通过判断这个节点是null还是等于当前节点，判断是第一次来还是第二次来到当前节点。特点是空复O(1)，不用栈
- **二叉树的反序列化**：二叉树的遍历其实就是序列化
    - 前序递归反序列化：用一个队列存储反序列化得到的节点，每次取出一个节点，这个节点就是头节点，剩下的队列先分配左子树，再分配右子树
    - 层遍历反序列化：反序列化节点数组 + 辅助队列，首先将数组第一个节点入列，后面只要队列不空就进入循环体，循环体中每次从队列取出1个元素，从数组中取出2个元素分别为队列取出元素的左右孩子，这2个孩子若非空也入列
- **利用前序中序数组反序列化**：前序特点-第一个节点就是头节点，中序特点-找到了头节点，就知道左子树和右子树的数组部分，再利用它找到前序的左子树右子树数组部分，递归求解。
- **二叉树的判断**：平衡/搜索都用递归
    - 完全：层遍历，若出现了左孩子null右孩子非null则不是，若出现了左孩子(非)null+右孩子null，则后面所有节点的左右孩子都必须是null，否则不是
    - 对称：中左右和中右左的序列化结果一致即可
- **二叉树打印**
    - 按层打印：多了left / next / cur(当前层号)辅助变量
    - 之字形打印：两个栈+存左右孩子顺序不一样
- **完全二叉树节点个数**：非线性时间复杂度，首先求最大高度(一直左漂)，然后每次判断左子树最后一层的最右节点是否为null，若是null则右子树是完全二叉树，节点个数用公式，反之左子树是完全二叉树
- **寻找两个节点的最近公共祖先**：首先求这两个节点的两条路径，然后问题就变成了求无环链表的公共节点



### 5栈与队列

- **实现栈/队列**：数组 + 辅助int | 双队列=>栈 | 双栈=>队列
- **栈的应用**
    - 后缀表达式：后缀表达式的生成规则 + 计算规则
    - 最值栈：两个栈实现
    - **单调栈**：从栈底往栈顶呈递增或递减趋势，方便找出数组每个元素相邻最近比它大或小的元素；注意相等元素的压栈处理；注意栈是压值还是压索引
- **双端队列**：队列从头到尾呈递增或递减趋势，可以O(1)找出区间的最大值或最小值；一般存储索引；区间增大入列时保证队列单调性+区间减小时要去除队列头部的过期元素
- **升级汉诺塔**：三个栈，先都push一个Integer.MAX_VALUE，规则决定了第一步必须从l=>m，后面每一步都是可以分析得到的
- **最长括号匹配子字符串**：遇到左括号压栈，若该左括号是栈底，则记它的索引为start，遇到右括号弹栈，若成功弹栈左括号，弹完的栈非空，则此时匹配长度为右括号-此时栈顶左括号索引；若弹完空了，则此时匹配长度为右括号-start。只有当遇到右括号弹栈失败(栈为空时)，才更新start(表明出现了不匹配，子串需要重新寻找)



### 6堆

- **数组实现堆**：父索引( (i-1) / 2)，孩子索引(2 * i + 1，2 * i + 2)。建大根堆，堆的最底层是最小的元素，所以扩大堆的数组位置时，需要做上浮过程，保证大数能浮上去(它已经不能再下沉了)。对于大根堆，改变了堆中某个数，如果增大了就**上浮**，变小了就**下沉**
- **堆的应用**
    - 实时获取数据流中位数：建一个大根堆，一个小根堆，分别存储前一半和后一办的数，插入时保证两个堆中数据量是平衡的，则中位数取决于两个堆顶
    - 做K次项目获利最多：创建项目对象，根据cost创建小根堆，根据profit创建大根堆，每次挑大根堆堆顶去做；注意次数和每次获利后更新小根堆和大根堆



### 7其他结构

- **前缀树**：Node有三个成员 next(HashMap)，pass(int)，end(int)，分别标记该节点的路径(多叉)，pass表示经过根节点到当前节点路径字符串的数量，end表示根节点到当前节点字符串的数量。注意pass和end都与当前节点的next无关，而取决于前面节点的路径，所以root节点的pass和end都是0。

    另外，在插入时的更新有三个：pass+end+节点(当路径节点不存在时)；删除时pass一定减1，end在适当的时候减1，如果遍历到某节点的pass=1，则直接删除该节点（前一个节点的next要remove这个路径key）





## 2算法思想

### 0排序

- **排序算法**

  - 选择 / 冒泡：基本

  - **插排**：思想是遍历元素，将元素插入到已有序的部分

  - **归并排序**：递归的思想，核心是merge。先排左右再merge，merge过程注意最后要将temp数组内容复制到源数组

  - **随机快排**：递归的思想，核心是partition。先partition再排左右。注意1.选取一个随机位置的数而不是随机位置索引，因为后续排序位置上数会变；2.partition终止条件是equal < big而不是 equal < p2

    ```java
    // 随机位置
    int randIndex = p1 + (int)(Math.random()*(p2 - p1 + 1));
    // 选定随机数在后面比较，不要用partition
    int rand = nums[randIndex];
    ```

  - **堆排**：首先建大根堆，然后每次交换堆顶和堆中最后一个位置的元素(相当于弹掉堆顶)，然后对交换后的堆顶做下沉，直到只剩堆顶。

  - 桶排：适用于元素大小范围已知的情况

  - **总结**：“快选堆”是不稳定排序算法；工程上小规模排序用插排因为它常数项小，对象排序用归并，因为它稳定。

- **数组排序后最大相邻差**：桶排序思想，将n个数分成n+1个桶，用布尔数组记录每个桶中是否有元素，最大相邻差一定出现所有的非空桶最小值-上一个非空桶的最大值中。使用两个数组纪录每个桶的最小值和最大值



### 1递归

- **基础递归**
  - 汉诺塔：汉诺塔能够分解成三步走递归，是因为第一步和第三步问题的模型和原问题是一样的，只是规模以及拥有盘子的杆不一样而已。**记住，一样模型问题才能递归！！**
  - **O(1)反转栈**：两个递归，第一个递归是每次都取到栈的最底下元素，第二个递归是取完所有栈最底下元素开始压栈
  - 打印九宫格字符串：7和9循环的次数是4，其他是3；8和9算字符开始位置时会多1位偏移量
- **复杂递归**
    - **复制粘贴字符串**：对于素数n，只能通过复制一个，然后一直粘贴得到，即答案是n。对于非素数n，找到n = i * j，保证i最小，则j最大，将j复制i份即可达到n个字符，所以递归关系关键是找到最小的因子。注意，找因子时，for循环上限是sqrt(n)，而不是n，可以减少无效遍历。这道题递归比dp更快，因为递归没有无效计算。
    - **n构成二叉搜索树**：以 i 为头节点， 1 ~ i - 1 作为左子树(这是必须的，因为搜索二叉树左子树的所有节点都必须比它小，同样比它小的所有元素也必须只能出现在头节点的左子树中)，i + 1 ~ n作为右子树，此时情况是两个不同规模同问题的笛卡儿积，遍历所有节点为头节点的情况和就是答案。使用双重循环(动态规划)，依次求出1 ~ n-1规模的答案，最后n规模的答案。这也是一种分治的思想



### 2分治

- **边界(中点)**：中点mid = (left + right) / 2，边界取[left, mid] 和 [mid + 1, right]

- **基本二分**

  - 求x的平方根：使用long类型，因为int类型的平方可能会溢出
  - 数字在排序数组中出现的次数：分别用二分法寻找左边界和右边界(找边界不同于找数)
  - **旋转有序数组问题**：若源数组中没有相等的元素，则比较num[mid] 和 num[left]一定能知道左边或右边是单调区间；若有相等值，在`num[mid]=num[left]=num[right]`时，无法判断，其他情况类似于前面，可以判断左边或右边是“近似单调区间”(可能有相等值)
  - **无序数组第k大的数**：随机partition，每次都可以判断是否击中，或者剩下的区域是在左边(小于区)找还是在右边(大于区)找。

- **复杂二分**

  - **两个有序数组第k大的数**：对k进行二分：每次分别取出两个数组k/2个数(若某个数组取不出来k/2个数，大数组直接舍弃前k/2个数)，舍去较小的那k/2个数，若某个数组舍弃完k/2个数刚好都走完了，那直接在另一个数组中找到答案
  - **表达式加任意括号的结果**：表达式根据运算符可以分成两部分，这两部分又都是合法的表达式，递归求这两部分加括号后的结果集，将左右两边的结果集求笛卡尔集
  - **字符串ip地址**：字符串需要分成4份，首先找合法的第1份，然后把剩下的字符串递归分成3份求结果集，将第一份与结果集拼凑起来就是合法的ip地址。（同样求字符串分成3份也是递归求解）注意，当第一位为0时，它必须占ip地址的一位

  

### 3双指针

- **有序数组的和问题**
  - 子数组累加和为定值：p1在0位置，p2在1位置开始往右走，大了就p1++，小了就p2++
  - 2sum和3sum问题：p1在0位置，p2在最后一个位置，小了就p1++，大了就p2--
- **蓄水池问题**：p1在0位置，p2在1位置，一开始水池的宽度是最大的，然后是p1++还是p2--呢？它们带来的影响都是水池宽度-1，所以当然让num[p1]和num[p2]中较小者移动，因为是较小值决定了蓄水量
- **丑数**：用p2/p3/p5三个指针分别纪录它们乘以相应因子后大于当前最大丑数的位置，则下一个丑数就是这三个位置*因子的最小值，每次求完一个丑数更新这三个位置
- **不重复的最长子字符串**：p1在0位置，p2在1位置，用一个map记录每个字符出现最晚的位置，p2往右走的时候，每次查找p2字符在map中记录的位置，若存在则p1位置可能要更新：map中记录的位置+1和p1当前位置取较大者，因为map中的位置可能此时已不在p1 ~ p2范围内



### 4位运算

- **包含1的个数**：不断消除最右侧的1，即可知。通过`n & (n - 1)`即可消除最右侧的1
- **数组中两个只出现一次的数**：异或结果最右侧的1，显示这两个数在这一位是不同的
- **位运算做加法**：位运算 + 进位递归
- **N皇后问题**：pie na col 0表示可以放皇后，1表示不可以；每次`~(pie | na | col) & ((1<<n) - 1)`得到了当前可以放皇后的位置(当前1表示可以)，然后在循环体中每次取出和消除最右的1：取出最右的1=>`tmp = n & (-n)`；消除最右的1=>`p = p&(p-1)`，利用取出最右的1模拟放置当前的皇后对下一行的影响：`col | tmp` `(pie | tmp) << 1` `(na | tmp) >> 1`，直到p=0，表明模拟完了当前行所有可以填皇后的位置



### 5贪心

- **哈夫曼编码问题**：将一个大数每次切割成两份，切割成指定的序列，最小切割代价是从结果序列来看，每次取最小的两个进行切割。典型问题：切割黄金

- **字符串集合的最小字典序**：即堆字符串集合(数组)进行排序，排序要求是最小字典序，排序比较器是(str1 + str2) - (str2 + str1)，当然字符串不能坐减法，这里是针对每个字符

    子问题：数组自由交换数字位置，使整个数组拼起来数字最小。需要使用贪心，不是倒序排数组(因为元素不只是小于9的数)！

- **数组子序列最大乘积**：记录遍历到每一个位置的最大值与最小值，本次的最大值只可能有4种可能：上一次最大值 * nums[i] / 上一次最小值 * nums/ 上一次最大值 / arr[i]；最小值同理，每次遍历到结束即可。(遇到0直接跳过，0为最大值只有一种特殊情况：0+负数）



### 6回溯

- **回溯常用技巧和注意事项**

    - 常见的排列组合问题，传递到下一层的可能有源数组+源数组索引/目标数组+目标数组索引。源数组索引一般用于指导本次循环从哪里开始，目标数组索引用于指导本次目标数组填充的位置
    - 如果目标数组长度不固定，那么用ArrayList代替，记得add后remove
    - 排序有时候对剪枝和排重有帮助
    - 常见的两种剪枝：可选元素数量少于组合剩下需要的元素数量；当前排序的最小元素已经大于剩下的组合和，直接break
    - 排重一般是排序+辅助布尔数组(一般用全局变量)+重复元素使用规则(重复元素必须“捆绑使用”，即当前元素若想在排列组合中使用，必须保证它前面的重复元素已在排列组合中使用)，即重复元素多了一个不能使用的情况：当它前面重复的元素未使用时，它也不能被使用

- **n对括号的有效排列**：用leftUse和rightUse分别表示左括号和右括号的使用数量，问题变成了在2n个位置填左括号和右括号。每个位置有两种选择(2次递归)，右括号填的时候有一个特殊条件：`rightUse < leftUse`，而左括号填的时候没有条件。注意，使用leftUse=n || rightUse=n进行剪枝，因为此时后面的情况都是固定的

    此类回溯递归内没有循环体，因为每次递归的选择只有两种：左括号和右括号。所以不是所有回溯递归内都要循环！！

- **和为定值的二叉树路径**：每个节点的下一次选择最多有两个，当左右孩子都为null的时候是base-case，此时栈内压的所有节点就是一条路径，此时验证栈内和即可。注意离开当前节点时需要弹栈还原到进入当前节点的状态

- **搜索**

    - **二维矩阵中搜单词**：遍历二维矩阵中的每一个点，以每一个点作为单词第一个匹配点进行搜索，回溯时需要传递给下一层的有：二维矩阵下一个搜索位置+字符串目前搜到的位置；当它们相等时，可以对二维矩阵位置的上下左右进行递归搜索，上下左右借助二维辅助数组可以用一个for遍历。因为不能走回头路，所以需要使用一个布尔数组记录走过的路径，一样需要记得还原。
    - **正则表达式匹配**：难点在于当exp第i+1位出现`*`时，只要str第i位和exp第i位匹配，就可以进行一次尝试：将str的第i+1位及以后和exp第i+2位及以后进行匹配，失败也不要紧，可以继续看str的第i+1位是否与exp的第i位匹配，如果匹配可以继续尝试：将str的第i+2位及以后和exp第i+2位及以后进行匹配...这其中有任何一个成功即成功，所有的都不成功也没关系，继续将str移动到的p1位置及以后和exp的第i+2位置开始匹配即可。

- **排列**

    - 全排列：比较难的情况是源数组中含有重复的元素，但是要求排列不能有重复结果，此时需要排重
    - 第k个排列：灵活运用剪枝。在某次循环中，当前元素选定后，剩下的排列数是剩下元素的阶乘，若它小于k，则表明第k个排列肯定不在当前元素选定的情况，此时剪枝，直接将k减小，然后跳下一次循环(不用在当前元素选定的情况下浪费时间)

- **组合总和**：一般都会要求组合不重复，即[1 1 7]和[7 1 1]是重复的结果

    - 情况1：源数组无重复元素，每个元素只能选1次，求不重复的总和。此时每次循环从上一次选定的下一个位置开始，并且有两个剪枝：1.若剩下可选的元素数量已经少于组合剩下需要的元素数量；2.若当前的元素(已排序，可选的最小值)已经大于剩下的组合总和，那么后面的情况都不用考虑了，直接break
    - 情况2：源数组有重复元素，每个元素可以选任意次，不限组合长度。比情况1复杂，首先选任意次的变化是，每次循环就从上一次选定的位置开始。其次保证重复元素不带来重复组合结果，需要排重：排序+布尔数组+不满足的条件。最后不限组合长度，所以没有了长度的剪枝，并且记录选取情况也需要使用ArrayList，而不是数组

- **子集**：子集问题区别于排列组合，排列组合都是每个位置有很多选择，所以递归里需要循环，子集相当于对每个元素做一个选和不选的抉择，只有2种情况(2次递归)，是**不需要递归内循环的！！**

    - 子集II：源数组有重复元素。子集长度不定，所以用ArrayList，add后记得remove；排重：每个位置做不选择的时候都是ok的，但选的时候需要判断它是否不满足**”重复元素捆绑使用条件“**，若不满足则不能选

  

### 7动态规划

- **常见题型**：最大值最小值 / 方案总数 / 是否可行 （答案都是一个结果值）

- **一般步骤**：确定`dp[i][j]`的含义；得到它的递推式；确定它的结果是哪一个dp；计算base-case，根据base-case递推计算。

- **斐波那契数列**：当前数等于序列前面有限个数和构成，分析场景是否满足。奶牛生产/爬楼梯/街区强盗/环形街区强盗(分情况变成两种直线街区情况)

- **矩阵路径**：矩阵最小路径和 / 矩阵路径总数

- **问题规模分割**：都是遍历当前所有的分割情况，求出一个满足条件的最值，然后用于指导后面所有的分割情况。

    - **分割整数的最大乘积**：`dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j))`，容易遗漏的情况是i * (i - j)，因为dp[i - j]不一定能取到i - j，也不一定恒大于i-j，即将其分成两个数相加和的情况不能漏。
    - **按平方数分割的最小分割量**：`dp[i] = Math.min(dp[i], dp[i-j]+1) (j是不大于i的平方数)` 可以首先**使用加法**求出所有小于等于n的平方数
    - **n个骰子的所有和情况统计**：第n个骰子出现的点数有6种可能，骰子和范围是`n~6n`，第n-1个骰子的和也有范围

- **等差递增子数组个数**：dp[i]表示以第i个位置结尾的等差递增子数组个数，而不是`0 ~ i`构成的数组的等差递增子数组个数，注意区别这两者！！前者的结果并不是dp[n]，后者的结果是dp[n]，但是后者不好得到递推式。使用前者的状态容易得到递推式

    ```
    dp[i] = dp[i-1] + 1(when第i/i-1/i-2位置成等差数列时)
    dp[i] = 0(when第i/i-1/i-2位置不成等差数列时)
    ```

    最后的结果是所有dp[i]的总和，这道题启示DP问题**不一定要求某个DP值就是题目答案**。找递推式时，dp[i]含义(状态)的确定，应尽量以好得到递推式为准。

- **最长子序列**：子序列不是子数组，不要求连续

    - **最长递增子序列**：dp[i]表示`0~i`组成的数组的最长递增子序列长度，遍历`0~i-1`的位置j，只要满足`arr[j] < arr[i]`，就有`dp[i] = Math.max(dp[i], dp[j] + 1)`。起始条件所有dp[i] = 1

    - **最长摆动子序列**：比较有意思，用up和down两个数表示遍历到第i位置时，最后是递增 和 最后是递减的最长摆动子序列长度。所以有以下递推式，最后结果是up和down的较大值

        ```
        if(nums[i] > nums[i-1]){
        up = down + 1;
        }
        if(nums[i] < nums[i-1]){
        down = up + 1;
        }
        ```

    - **最长公共子序列**：**双序列的DP问题**，`dp[i][j]`表示以第一个数组 i 位置结尾和第二个数组 j 位置结尾的两个数组的最长公共子序列。有以下递推式

        ```
        dp[i][j] = dp[i-1][j-1] + 1 (当num1[i] == num2[j])
        dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) (当 num1[i] != num2[j])
        ```

        因为`num1[i] == num2[j]`时表明第i个元素和第j个元素已经在公共子序列中做了贡献，所以可以都去掉。若它们不相等，表明至少有一个在公共子序列中是没有贡献的

        **子问题**：删除两个字符串的若干个字符， 使这两个字符串相等，求最少删除数量。等价于求最长公共子序列
        
    - **最长公共子串**：放在一起进行比较，也使用`dp[i][j]`表示以 i 和 j 结尾的最长公共子串，由于子串不同于子序列，所以它们的递推式有变化：

        ```
        dp[i][j] = dp[i-1][j-1] + 1 (当num1[i] == num2[j])
        dp[i][j] = 0 (当 num1[i] != num2[j])
        ```

        它们不相等时，以它们结尾且相等的子串自然不存在了。另外，显然答案也不再是`dp[m][n]`，而是所有`dp[i][j]`的最大值

- **双序列问题**：指的是有两个序列，上面的最长公共子序列以及它的子问题，其实就是一个双序列问题

    - **编辑两个字符串使它们相等**：`dp[i][j]`表示编辑使第一个字符串的前i位与第二个字符串的前j位相等的最少编辑次数。递推式如下：

        ```
        dp[i][j] = dp[i-1][j-1] (当word1[i-1] == word2[j-1])
        dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 (当word1[i-1] != word2[j-1])
        ```

        理解一下，当word1的第i位与word2的第j位不相等时，如果做增加操作，就是在word1的第i后增加一个word2[j]，所以后面就不用再处理word2的第j位，问题规模变成`dp[i][j-1]`；如果删除word1的第i位，问题规模变成`dp[i-1][j]`；如果替换word1的第i位为word2[j]，问题规模变成`dp[i-1][j-1]`，所以选它们的较小者。

        需要注意的是，是修改word1使其匹配word2。而不是两个都修改

- **扔鸡蛋判断层高**：`dp[i][j]`表示有i个鸡蛋，有j层楼需要判断，假设首先在第k层扔了一个鸡蛋，那么有两种可能蛋碎或蛋没碎，也对应两种剩余判断楼层数，这两种应该取最大值，因为碎不碎是由题目决定的；而k不同时，这些最大值不同，在这些不同的最大值中选最小值，因为k是我们自己决定的。递推式如下：

    ```
    dp[i][j] = min(max(dp[i-1][k-1], dp[i][j-k]) + 1) (其中k < j)
    ```

- **数字字母解码**：`1~26`分别表示`a~z`，给一个数字字符串，问有多少种解码可能。只看最后一个数字，它有两种可能：1.自己单独组成一个字母；2.和倒数第二位组成一个字母。因为它的递推式为：

    ```
    dp[i] = dp[i-1](当第i个数字可以单独构成一个字母时) + dp[i-2](当第i个数字和第i-1个数字能够一起构成一个字母时)
    ```

- **格雷码：**每一位和前一位的二进制只差一位，必须从0开始。n位和n+1位的格雷码数量差了两倍，n+1位格雷码的前`2^n-1`位就是第n位格雷码，后面的格雷码就是前面格雷码倒序然后在首位+1。格雷码问题

- **股票交易系列问题**

    - 只允许交易一次和允许交易无数次是最简单的, 前者遍历和当前最小值作差取最大, 后者只要昨天比今天便宜, 就可以加上昨天今天的利息差

    - **只允许交易两次**是有限的四个状态: firstBuy，firstSell，secondBuy和secondSell. 遍历股价, 每天都对四种状态做判断(判断每个状态是否在当天进行, 就比较进行和不进行取最值就行), 每天都要对secondSell的价格做判断和结果取较大值

    - **只允许交易K次**, 引入yesDP和noDP两个DP值, 即它们的dp实际有三个变量: 当天是否持有股票  / 第几天 / 已经交易的次数, 但是因为持否持有股票只有有或无两种, 所以可以直接**使用yesDP和noDP两个DP**表示, 避免了使用三维的DP值. yesDP与noDP互相依赖, 最终的结果是`noDP[n - 1][k]`的最大值(k<=K)

        当K >= n/2时, 是特殊情况. 此时和交易无数次等价

    - **有手续费(允许交易无数次)**, 也是引入yesDP和noDP两个DP值, 但是因为交易次数没有限制, 所以少了一个状态, 因此yesDP和noDP都是一维的, 注意手续费只有在卖股票的时候才扣

    - **有冷冻期(允许交易无数次)**, 也是引入yesDP和noDP两个DP值, 同样是一维的. 同样需要注意, 只有在卖股票的时候, 才会冷冻1天, 因此买股票的时候需要考虑是否处于冷冻期不能买, 卖的时候是不用考虑的. 

        另外, 这里的yesDP递推式有些不理解

        ```
        yesDP[i] = max{yesDP[i-1], noDP[i-2]-prices[i]} 
        ```

        第i天持有股票的情况: 第i-1天已持有, 或第i-2天未持有, 第i天(不可能处于冷冻期)买了.  这里不是少了一种情况吗? 就是第i-1天未持有, 但是不是在第i-1天卖的, 所以第i天不处于冷冻期, 第i天也可以买. 是不是可以证明这一种情况的DP值肯定没有前面两种大?

        如果和我一样对有冷冻期yesDP的递推式疑惑, 可以考虑冷冻期的yesDP和noDP加一种状态, 表示是否在当天卖出. `yesDP[i][0]`表示在第i天的时候持有股票(当天交易后持有因此不可能在当天卖出, 所以没有`yesDP[i][1]`的状态), `noDP[i][0]`表示在第i天不持有股票, 但是并不是在第i天卖的, `noDP[i][1]`表示在第i天不持有股票, 并且就是在第i天卖出的. 这样多了一些状态, 但是递推式理解起来就方便一些.

- **背包问题**：在组合问题上，用DP的背包问题思路和回溯的思路都可以做，回溯可以找到每一种组合，DP可以快速找到组合的总数

    - **01背包问题和完全背包**问题都可以用`dp[i][j]`表示状态,进而根据实际情况推出状态方程. `dp[i][j]`表示的是遍历到第i件物品时, 满足体积不超过j的最大价值.  `dp[i][j]`可以分解成若干个`dp[i-1][k]`的状态之和. 它们的状态方程含义核心都是: 这个物品我选0个还是k个? 区别只是01背包问题k只能选1, 完全背包问题k可以选满足条件的任意值

    - **多维属性背包**问题, 无非就是多了一个状态, 即用`dp[i][j][k]`表示遍历到第i件物品时, 满足体积不超过j且重量不超过k的最大价值, 同样它一般也可以表示成若干个dp[i-1]状态之和. 

        因为一般都只和上一个状态相关, 所以往往还可以做空间优化. 可以看到01背包问题 / 完全背包 / 多维属性背包问题在写状态方程(递推式)时都关注的是, **当前遍历到的物品我选多少个?** 所以物品的循环是外层循环, 表示我每次做选择时, 只能选择当前物品, 但是选择的个数是我可以控制的

    - **涉及顺序的背包**问题, 它在写状态方程时, 不再关注说这个物品我选多少个了, 因为同样是选3个, 但是不同顺序对应不同结果, 所以这样继续这样思考是会漏结果的. 思考方式变成了: **第一个位置我选什么物品?** 因为思考方式不一样, 所以涉及顺序的背包问题, 在遍历时, 物品的循环不再是外层循环, 而是内层循环, 表示我每次做选择时都可以选择所有的物品.

    

### 8数学算法

- **KMP字符串匹配**：主字符串str1，待匹配字符串str2，问题是str1是否包含str2：利用str2的next数组指导str1与str2的匹配过程

    - str2的next数组求解：next[0] = -1, next[1] = 0，求next[i]时判断arr[i-1]是否等于某个`arr[next[p]]`，如果找到表明next[i] = next[p] + 1，否则next[i] = 0
    - next数组对匹配的指导：比如str1已经匹配到了p1位置，str2匹配到了p2位置，此时这两个位置元素不相等，则需要不停将p2移动到next[p2]位置，直到next[p2]=0，表明匹配字符串需要重新开始匹配，所以p1++，也重新开始匹配

- **KMP子问题**

    - **尾部追加最短字符串获得两个相同字符串**：求next数组求到str.length()位置，即获得最后一位的最大相等前缀，copy这两段相等字符串之间的字符串即可
    - **判断一棵树是否是另一颗树的子树**：序列化，然后字符串匹配

- **Manacher求最长回文子串**：先对字符串进行符号填充(用i1 i2两个辅助int)，然后遍历求每个位置的r：当前遍历位置如果在R左边，则可以利用对称指导当前遍历的初始暴力扩半径(较小值)，每次扩完记录r，并判断是否需要更新C/R和maxPos/maxR。最后可以还原最长回文子串(也是通过i1, i2两个辅助int)

- **Manacher子问题**

    - **尾部追加最短字符串得到回文串**：遍历求r过程中，第一次R达到字符串最后一个字符即停止，然后复制前面未回文部分

- **BFPRT**：求第k小个数的严格O(N)方法，本质还是partition，只是选数有讲究，不再随机选，并且用了递归

- **特殊技巧**

    - **`1~n`所有数1出现的次数**：根据不同位去判断，同时考虑到所在位数字比较特殊的情况，比如=0 或 = 1 或 >1，将三种情况结合在一起的代码如下：可以认为a是当前判断位左边的数(包括当前位)，b是当前判断位右边的数。比如31156，判断百位1出现的次数时，a=311，b=56

        ```java
        public int NumberOf1Between1AndN_Solution(int n) {
            int cnt = 0;
            for (int m = 1; m <= n; m *= 10) {
                int a = n / m, b = n % m;
                cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
            }
            return cnt;
        }
        ```

    - **约瑟夫环问题**：推导去掉第一个元素后序列和原序列的映射关系，得到关系式：`f(n,m) = (f(n-1,m)+ m) % n`

    - **小孩分糖果问题**：正反遍历，正遍历的时候满足正向条件即可，反向遍历时如果违背了反向条件，就作改变



  

  

