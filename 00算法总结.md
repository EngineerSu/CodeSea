## 0数据结构

### 0数组

- **打印矩阵**：打印路径可循环，找到位置指针指导打印路径

- **O(1)找数组出现超过一半的数**

- **O(1)找数组(1~n)中任一个重复的数字**

- **子数组最大和**：当前和sum若小于0，则sum从当前位置重新开始，否则继续累加

- **和为定值的最长子数组**：记录0~i的所有累加和sum[i]，则找sum[j] = target - sum[i]，表明j~i的累加和是target，j应该是`target - sum[i]`出现的最早位置

    子问题有：奇偶个数相同的最长子数组，0与1个数相同的最长子数组。总之核心是**最长子数组**

- **全排列值的下一个递增排列**：弄清楚全排列值递增的规则

- **整数对的最长递增链**：二维数组排序的lambda表达式` Arrays.sort(pairs,(a, b) -> (a[1] - b[1]));`



### 1字符串

- **翻转字符串**：先整体翻转，再各部分翻转



### 2哈希表

- **拷贝有random指针的链表**：map存储了旧新节点对应关系，以旧找新
- **getRandom的Set实现**：两个map，一个存位置元素对应关系，一个存元素位置对应关系，删除元素时，将最后一位元素移动到被删除的序号位置，保证位置序号一直是连续的
- **单词替换字母形成新单词**：单词少任一个字母，可以得到很多key，都和该单词组成键值对存储，处理完所有单词问题就ok了



### 3链表

- **翻转链表**：每次都只修改cur和pre的指向关系，next的存在是为了备份下一个循环节点
- **找链表中点**：slow在0位置，fast在1位置，开始走，直到fast或fast.next是空，slow停在了中点位置(偶数个靠左)
- **判断链表回文**：栈 或 找到中点翻转右边链表再比较，最后要还原
- **判断链表有环**：slow在0位置，fast在1位置，直到相遇就有环，fast停下，slow继续走到再次相遇的步数就是环长，此时fast/slow都回0位置，速度一样，让fast先走环长，再一起走再次相遇在入环节点
- **判断链表相交**：无环和无环相交 / 有环和有环相交
- **链表排序**：排序的大体思想和数组一样，但是具体技巧不同
    - 插排：创建一个新链表存放已经遍历过的有序部分，后面遍历的每个元素都插排到新链表中
    - partition：需要smallHead/smallTail equalHead/equalTail bigHead/bigTail六个辅助节点
    - merge：需要newHead/newTail两个辅助节点



### 4树

- **二叉树非递归遍历**
    - 前序-中左右：先压栈头节点，只要栈不是空，就弹出一个元素并打印(输出到遍历结果中)，然后判断右孩子非null压栈，左孩子非null压栈
    - 中序-左中右：头节点非null或栈不为空都可以进循环体，如果头节点是null表明上一次(右滑)的右孩子是null，此时弹栈一个节点打印，并右滑；如果头节点非null则判断它左孩子是否也非null，左孩子非null则当前节点压栈，直到左孩子是null，则打印当前节点并右滑
    - 后序-左右中：相当于中右左的倒序，所以改造一下前序，再把结果倒一下即可
    - 层遍历：头节点入列，只要队列不是空，每次出列一个节点并打印，然后判断左右孩子是否非null，非null则入列
    - Morris遍历：用左子树的最右节点指向当前节点，通过判断这个节点是null还是等于当前节点，判断是第一次来还是第二次来到当前节点。特点是空复O(1)，不用栈
- **二叉树的反序列化**：二叉树的遍历其实就是序列化
    - 前序递归反序列化：用一个队列存储反序列化得到的节点，每次取出一个节点，这个节点就是头节点，剩下的队列先分配左子树，再分配右子树
    - 层遍历反序列化：反序列化节点数组 + 辅助队列，首先将数组第一个节点入列，后面只要队列不空就进入循环体，循环体中每次从队列取出1个元素，从数组中取出2个元素分别为队列取出元素的左右孩子，这2个孩子若非空也入列
- **利用前序中序数组反序列化**：前序特点-第一个节点就是头节点，中序特点-找到了头节点，就知道左子树和右子树的数组部分，再利用它找到前序的左子树右子树数组部分，递归求解。
- **二叉树的判断**：平衡/搜索都用递归
    - 完全：层遍历，若出现了左孩子null右孩子非null则不是，若出现了左孩子(非)null+右孩子null，则后面所有节点的左右孩子都必须是null，否则不是
    - 对称：中左右和中右左的序列化结果一致即可
- **二叉树打印**
    - 按层打印：多了left / next / cur(当前层号)辅助变量
    - 之字形打印：两个栈+存左右孩子顺序不一样
- **完全二叉树节点个数**：非线性时间复杂度，首先求最大高度(一直左漂)，然后每次判断左子树最后一层的最右节点是否为null，若是null则右子树是完全二叉树，节点个数用公式，反之左子树是完全二叉树
- **寻找两个节点的最近公共祖先**：首先求这两个节点的两条路径，然后问题就变成了求无环链表的公共节点



### 5栈与队列

- **实现栈/队列**：数组 + 辅助int | 双队列=>栈 | 双栈=>队列
- **栈的应用**
    - 后缀表达式：后缀表达式的生成规则 + 计算规则
    - 最值栈：两个栈实现
    - **单调栈**：从栈底往栈顶呈递增或递减趋势，方便找出数组每个元素相邻最近比它大或小的元素；注意相等元素的压栈处理；注意栈是压值还是压索引
- **双端队列**：队列从头到尾呈递增或递减趋势，可以O(1)找出区间的最大值或最小值；一般存储索引；区间增大入列时保证队列单调性+区间减小时要去除队列头部的过期元素
- **升级汉诺塔**：三个栈，先都push一个Integer.MAX_VALUE，规则决定了第一步必须从l=>m，后面每一步都是可以分析得到的
- **最长括号匹配子字符串**：遇到左括号压栈，若该左括号是栈底，则记它的索引为start，遇到右括号弹栈，若成功弹栈左括号，弹完的栈非空，则此时匹配长度为右括号-此时栈顶左括号索引；若弹完空了，则此时匹配长度为右括号-start。只有当遇到右括号弹栈失败(栈为空时)，才更新start(表明出现了不匹配，子串需要重新寻找)



### 6堆

- **数组实现堆**：父索引( (i-1) / 2)，孩子索引(2 * i + 1，2 * i + 2)。建大根堆，堆的最底层是最小的元素，所以扩大堆的数组位置时，需要做上浮过程，保证大数能浮上去(它已经不能再下沉了)。对于大根堆，改变了堆中某个数，如果增大了就**上浮**，变小了就**下沉**
- **堆的应用**
    - 实时获取数据流中位数：建一个大根堆，一个小根堆，分别存储前一半和后一办的数，插入时保证两个堆中数据量是平衡的，则中位数取决于两个堆顶
    - 做K次项目获利最多：创建项目对象，根据cost创建小根堆，根据profit创建大根堆，每次挑大根堆堆顶去做；注意次数和每次获利后更新小根堆和大根堆



### 7其他结构

- **前缀树**：Node有三个成员 next(HashMap)，pass(int)，end(int)，分别标记该节点的路径(多叉)，pass表示经过根节点到当前节点路径字符串的数量，end表示根节点到当前节点字符串的数量。注意pass和end都与当前节点的next无关，而取决于前面节点的路径，所以root节点的pass和end都是0。

    另外，在插入时的更新有三个：pass+end+节点(当路径节点不存在时)；删除时pass一定减1，end在适当的时候减1，如果遍历到某节点的pass=1，则直接删除该节点（前一个节点的next要remove这个路径key）





## 1算法思想

### 0排序

- **排序算法**

  - 选择 / 冒泡：基本

  - **插排**：思想是遍历元素，将元素插入到已有序的部分

  - **归并排序**：递归的思想，核心是merge。先排左右再merge，merge过程注意最后要将temp数组内容复制到源数组

  - **随机快排**：递归的思想，核心是partition。先partition再排左右。注意1.选取一个随机位置的数而不是随机位置索引，因为后续排序位置上数会变；2.partition终止条件是equal < big而不是 equal < p2

    ```java
    // 随机位置
    int randIndex = p1 + (int)(Math.random()*(p2 - p1 + 1));
    // 选定随机数在后面比较，不要用partition
    int rand = nums[randIndex];
    ```

  - **堆排**：首先建大根堆，然后每次交换堆顶和堆中最后一个位置的元素(相当于弹掉堆顶)，然后对交换后的堆顶做下沉，直到只剩堆顶。

  - 桶排：适用于元素大小范围已知的情况

  - **总结**：“快选堆”是不稳定排序算法；工程上小规模排序用插排因为它常数项小，对象排序用归并，因为它稳定。

- **数组排序后最大相邻差**：桶排序思想，将n个数分成n+1个桶，用布尔数组记录每个桶中是否有元素，最大相邻差一定出现所有的非空桶最小值-上一个非空桶的最大值中。使用两个数组纪录每个桶的最小值和最大值



### 1递归

- **基础递归**
  - 汉诺塔：汉诺塔能够分解成三步走递归，是因为第一步和第三步问题的模型和原问题是一样的，只是规模以及拥有盘子的杆不一样而已。**记住，一样模型问题才能递归！！**
  - **O(1)反转栈**：两个递归，第一个递归是每次都取到栈的最底下元素，第二个递归是取完所有栈最底下元素开始压栈
  - 打印九宫格字符串：7和9循环的次数是4，其他是3；8和9算字符开始位置时会多1位偏移量



### 2分治

- **边界(中点)**：中点mid = (left + right) / 2，边界取[left, mid] 和 [mid + 1, right]

- **基本二分**

  - 求x的平方根：使用long类型，因为int类型的平方可能会溢出
  - 数字在排序数组中出现的次数：分别用二分法寻找左边界和右边界(找边界不同于找数)
  - **旋转有序数组问题**：若源数组中没有相等的元素，则比较num[mid] 和 num[left]一定能知道左边或右边是单调区间；若有相等值，在`num[mid]=num[left]=num[right]`时，无法判断，其他情况类似于前面，可以判断左边或右边是“近似单调区间”(可能有相等值)
  - **无序数组第k大的数**：随机partition，每次都可以判断是否击中，或者剩下的区域是在左边(小于区)找还是在右边(大于区)找。

- **复杂二分**

  - **两个有序数组第k大的数**：对k进行二分：每次分别取出两个数组k/2个数(若某个数组取不出来k/2个数，大数组直接舍弃前k/2个数)，舍去较小的那k/2个数，若某个数组舍弃完k/2个数刚好都走完了，那直接在另一个数组中找到答案
  - **表达式加任意括号的结果**：表达式根据运算符可以分成两部分，这两部分又都是合法的表达式，递归求这两部分加括号后的结果集，将左右两边的结果集求笛卡尔集
  - **字符串ip地址**：字符串需要分成4份，首先找合法的第1份，然后把剩下的字符串递归分成3份求结果集，将第一份与结果集拼凑起来就是合法的ip地址。（同样求字符串分成3份也是递归求解）注意，当第一位为0时，它必须占ip地址的一位

  

### 3双指针

- **有序数组的和问题**
  - 子数组累加和为定值：p1在0位置，p2在1位置开始往右走，大了就p1++，小了就p2++
  - 2sum和3sum问题：p1在0位置，p2在最后一个位置，小了就p1++，大了就p2--
- **蓄水池问题**：p1在0位置，p2在1位置，一开始水池的宽度是最大的，然后是p1++还是p2--呢？它们带来的影响都是水池宽度-1，所以当然让num[p1]和num[p2]中较小者移动，因为是较小值决定了蓄水量
- **丑数**：用p2/p3/p5三个指针分别纪录它们乘以相应因子后大于当前最大丑数的位置，则下一个丑数就是这三个位置*因子的最小值，每次求完一个丑数更新这三个位置
- **不重复的最长子字符串**：p1在0位置，p2在1位置，用一个map记录每个字符出现最晚的位置，p2往右走的时候，每次查找p2字符在map中记录的位置，若存在则p1位置可能要更新：map中记录的位置+1和p1当前位置取较大者，因为map中的位置可能此时已不在p1 ~ p2范围内



### 4位运算

- **包含1的个数**：不断消除最右侧的1，即可知。通过`n & (n - 1)`即可消除最右侧的1
- **数组中两个只出现一次的数**：异或结果最右侧的1，显示这两个数在这一位是不同的
- **位运算做加法**：位运算 + 进位递归
- **N皇后问题**：pie na col 0表示可以放皇后，1表示不可以；每次`~(pie | na | col) & ((1<<n) - 1)`得到了当前可以放皇后的位置(当前1表示可以)，然后在循环体中每次取出和消除最右的1：取出最右的1=>`tmp = n & (-n)`；消除最右的1=>`p = p&(p-1)`，利用取出最右的1模拟放置当前的皇后对下一行的影响：`col | tmp` `(pie | tmp) << 1` `(na | tmp) >> 1`，直到p=0，表明模拟完了当前行所有可以填皇后的位置



  

  

  

