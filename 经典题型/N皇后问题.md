## N皇后问题

Q：在N*N的棋盘（矩阵，二维数组）中，要存放N个皇后，使她们互不攻击，即不能同一行，不能同一列，也不能在一条对角线上。求有多少种摆放皇后的方法

A：每一行只能摆放一个皇后，用深度遍历，遍历到每一行时，求这一行还能有哪些列能摆放皇后，如果没有能摆放皇后的位置，则说明前面行摆放皇后的位置不满足条件，提前返回；若遍历完了所有行，表明完成了一次有效的摆放，则摆放次数+1。关键点：如何判断这一行还有哪些列能摆放皇后？

方法1：用遍历的方法，针对每列摆放皇后进行查看它的每行每列两条对角线，观察是否冲突。

方法2：col，pie，na是三个int整数，用三个整数二进制位的0~N位表示当前行的列是否可以放置皇后，为0的时候表示这个列可以放置皇后，为1的时候表示这个列不可以放置皇后。假设N=10，当前行的第5列放置了皇后，那么col的第五位就要置1，pie表示当前行第5列那个格点左下角的对角线列，所以pie第五位也先置1，再左移一位，因为pie表示的由于前面已放置皇后带来的，左对角线不能存放皇后的列的位置，而左对角线每下移一行，也要左移一列；同理na也是第五位先置1，再右移一位。

S：注意逻辑运算和位运算不要混淆；对常见位运算的作用要熟悉；位运算优先级很低，注意带括号

````java
public static int getNQueen(int n){
    if(n <= 0){
        return 0;
    }

    return process(0, 0, 0, 0, n);
}

private static int process(int row, int col, int pie, int na, int n){
    if(row == n){
        return 1;
    }
    int cnt = 0;
    // col|pie|na中的0位表示还可以存放皇后的列，取反得到1位变成了可以存放皇后的列
    // 取反的时候，32位int前面一些0位变成了1，1<<N - 1作用是只取0~N位，其他位舍去
    int p = (~(col|pie|na)) & ((1<<n) - 1);
    while(p > 0){
        int cur = p & -p; // 得到cur最右边一位的1表示的二进制位
        // 将col，pie，na相关位置1，继续往下走
        cnt += process(row+1, col|cur, (pie|cur)<<1, (na|cur)>>1, n);
        p &= p-1; // 除去cur最右边一位1
    }

    return cnt;
}
````

